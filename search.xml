<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F07%2F8-7Task%2F</url>
    <content type="text"><![CDATA[1.编写异常类：空异常、年龄低异常、年龄高异常、 工资低异常、工资高异常、身份证非法异常。2.编写一个员工类，(1) 有属性： 编号，姓名，年龄，工资，身份证号码，员工人数，员工工资总额 (2) 有构造器： 构造器1：设置编号，年龄，姓名；如果年龄小于18，抛出年龄低异常；如果年龄大于60抛出年龄高异常，如果姓名为null或为空字符串，抛出空异常。 构造器2：设置工资，设置身份证号码；如果工资低于600，抛出工资低异常。 (3) 有方法 增加工资 addSalary(double addSalary)，抛出工资高异常，当增加后的工资大于员工工资总额时，抛出此异常。 减少工资 minusSalary(double minusSalary), 抛出工资低异常，当减少后的工资低于政府最低工资时，抛出工资低异常。 显示员工工资总额方法：showTotalSalary(), 抛出空异常，当工资总额为0时，抛出此异常。 显示员工人数：void showTotalEmployee（），抛出空异常。当员工人数为0时，抛出此异常。 2 编写一个程序实现以下功能：（1）产生5000个1～9999之间的随机整数，将其存入文本文件a.txt中。123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.List;import java.util.Random;public class Test &#123;public static void main(String[] args) &#123;List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(5000);Random random = new Random();for (int i = 0; i &lt; 5000; i++) &#123;Integer r = null;do// 由于要求1～9999，所以得排除0的情况r = random.nextInt(10000);while (r == 0);arr.add(random.nextInt(10000));&#125;try &#123;BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;C:\\a.txt&quot;)));for (Integer i : arr) &#123;bw.write(String.valueOf(i));bw.newLine();&#125;bw.close();&#125; catch (FileNotFoundException e) &#123;e.printStackTrace();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;&#125;``` （2）从文件中读取这5000个整数，并计算其最大值、最小值和平均值并输出结果。 import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.util.Random; public class Demo17 { public static void main(String[] args) throws Exception { /* * 编写一个程序实现以下功能：()考虑内存优化 ①产生5000个1～9999之间的随机整数，将其存入文本文件a.txt中。 ②从文件中读取这5000个整数，并计算其最大值、最小值和平均值并输出结果。 */ Random r = new Random(); File file = new File(&quot;G:/a/b/c/a.txt&quot;); FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw); for (int i = 0; i &lt; 5000; i++) { bw.write((r.nextInt(9999)+1)+&quot;&quot;); bw.newLine(); bw.flush(); fw.flush(); } bw.close(); fw.close(); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); String s=&quot;&quot;; int index=0; int a[] = new int [5000]; while((s=br.readLine())!=null) { System.out.println(s); a[index] = Integer.valueOf(s); index++; } System.out.println(&quot;最大值：&quot;+GetMax(a)); br.close(); fr.close(); } public static int GetMax(int [] a) { int max = a[0]; for (int i = 1; i &lt; a.length; i++) { if(a[i]&gt;max) { max =a[i]; } } return max; } }1#### 3 在电脑D盘下创建一个文件为HelloWorld.txt文件，判断他是文件还是目录，在创建一个目录IOTest,之后将HelloWorld.txt移动到IOTest目录下去；之后遍历IOTest这个目录下的文件 import java.io.File;import java.io.IOException; public class Test1 { /** * 1. 在电脑D盘下创建一个文件为HelloWorld.txt文件， * 判断他是文件还是目录，再创建一个目录IOTest, * 之后将HelloWorld.txt移动到IOTest目录下去； * 之后遍历IOTest这个目录下的文件 * * 程序分析： * 1、文件创建使用File的createNewFile()方法 * 2、判断是文件用isFile(),判断是目录用isDirectory * 3、创建目录用：mkdirs()方法 * 4、移动文件用：renameTo * 5、遍历目录用：list（）方法获得存放文件的数组，foreach遍历的方法把文件打印出来 * */ public static void main(String[] args) { //在电脑D盘下创建一个文件为HelloWorld.txt文件 File file=new File(&quot;D:&quot;,&quot;HelloWorld.txt&quot;); //创建文件，返回一个布尔值 boolean isCreate; try { isCreate = file.createNewFile(); if (isCreate) { System.out.println(&quot;创建文件成功！&quot;); }else { System.out.println(&quot;创建文件失败！文件已经存在&quot;); } } catch (IOException e) { System.out.println(&quot;创建文件失败！&quot;); } // 判断他是文件还是目录， if (file.isFile()) { System.out.println(&quot;这是一个文件&quot;); } else { System.out.println(&quot;这是一个目录&quot;); } //再创建一个目录IOTest File file2=new File(&quot;D:/IOTest&quot;); file2.mkdirs(); //HelloWorld.txt移动到IOTest目录下去?失败？》 if (file.renameTo(file2)) { System.out.println(&quot;文件移动成功！&quot;); } else { System.out.println(&quot;文件移动失败&quot;); } //遍历IOTest目录下的文件 String[] arr=file2.list(); for (String string : arr) { System.out.println(string); } } } 1 #### 4 递归实现输入任意目录，列出文件以及文件夹 import java.io.File;import java.io.IOException;public class Test1 { /** * 1. 在电脑D盘下创建一个文件为HelloWorld.txt文件， * 判断他是文件还是目录，再创建一个目录IOTest, * 之后将HelloWorld.txt移动到IOTest目录下去； * 之后遍历IOTest这个目录下的文件 * * 程序分析： * 1、文件创建使用File的createNewFile()方法 * 2、判断是文件用isFile(),判断是目录用isDirectory * 3、创建目录用：mkdirs()方法 * 4、移动文件用：renameTo * 5、遍历目录用：list（）方法获得存放文件的数组，foreach遍历的方法把文件打印出来 * */ public static void main(String[] args) { //在电脑D盘下创建一个文件为HelloWorld.txt文件 File file=new File(&quot;D:&quot;,&quot;HelloWorld.txt&quot;); //创建文件，返回一个布尔值 boolean isCreate; try { isCreate = file.createNewFile(); if (isCreate) { System.out.println(&quot;创建文件成功！&quot;); }else { System.out.println(&quot;创建文件失败！文件已经存在&quot;); } } catch (IOException e) { System.out.println(&quot;创建文件失败！&quot;); } // 判断他是文件还是目录， if (file.isFile()) { System.out.println(&quot;这是一个文件&quot;); } else { System.out.println(&quot;这是一个目录&quot;); } //再创建一个目录IOTest File file2=new File(&quot;D:/IOTest&quot;); file2.mkdirs(); //HelloWorld.txt移动到IOTest目录下去?失败？》 if (file.renameTo(file2)) { System.out.println(&quot;文件移动成功！&quot;); } else { System.out.println(&quot;文件移动失败&quot;); } //遍历IOTest目录下的文件 String[] arr=file2.list(); for (String string : arr) { System.out.println(string); } } }主方法调用类 import java.io.File;import java.util.List; public class Test2 { /** * 递归实现输入任意目录，列出文件以及文件夹 * * 设计：在FileUtils类里面实现了逻辑操作，在另一边调用就可以了 * */ public static void main(String[] args) { //比如输入D盘 Listlist=FileUtils.getAllFiles(&quot;D:&quot;); //输出所有的文件和文件夹的名字 for (File file : list) { System.out.println(file); } } } ` 5 建立exception包，建立Bank类，类中有变量double balance表示存款,Bank类的构造方法能增加存款，Bank类中有取款的发方法withDrawal(double dAmount),当取款的数额大于存款时,抛出InsufficientFundsException,取款数额为负数，抛出NagativeFundsException,如new Bank(100),表示存入银行100元，当用方法withdrawal(150)，withdrawal(-15)时会抛出自定义异常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Bank类package d0923;public class Bank &#123;private double balance;Bank(double a) &#123;balance += a;&#125;void withDrawal(double dAmount) throws InsufficientFundsException, NagativeFundsException &#123;if(dAmount&lt;0) throw new InsufficientFundsException(dAmount);if(dAmount&gt;balance)throw new NagativeFundsException();System.out.println(&quot;取款：&quot;+dAmount);this.balance-=dAmount;&#125;&#125;///InsufficientFundsExceptionpackage d0923;public class InsufficientFundsException extends Exception &#123;InsufficientFundsException(double i)&#123;System.out.println(&quot;发生错误：&quot;+&quot;取款额&quot;+i+&quot;为负数。&quot;);&#125;&#125;///NagativeFundsExceptionpackage d0923;public class NagativeFundsException extends Exception &#123;NagativeFundsException()&#123;System.out.println(&quot;超出余额：&quot;);&#125;&#125;package d0923;public class NagativeFundsException extends Exception &#123;NagativeFundsException()&#123;System.out.println(&quot;超出余额：&quot;);&#125;&#125;//测试主类package d0923;public class TestBank &#123;public static void main(String[] args) &#123;Bank b=new Bank(100);try&#123;b.withDrawal(-15);&#125;catch(InsufficientFundsException e)&#123;e.printStackTrace();&#125;catch(NagativeFundsException e)&#123;e.printStackTrace();&#125;try&#123;b.withDrawal(150);&#125;catch(InsufficientFundsException | NagativeFundsException e)&#123;e.printStackTrace();&#125;&#125;&#125;//运行结果发生错误：取款额-15.0为负数。 ///withdrawal调用的构造函数d0923.InsufficientFundsExceptionat d0923.Bank.withDrawal(Bank.java:12) /// printStackat d0923.TestBank.main(TestBank.java:8)超出余额：d0923.NagativeFundsExceptionat d0923.Bank.withDrawal(Bank.java:14)at d0923.TestBank.main(TestBank.java:20)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F07%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试原因：main运行才知道有问题-&gt;每个方法自己测试：单元测试 白盒测试：代码相关，单元测试，测试单个方法 黑盒测试：用户测试（自动化） JAVA只能提供简单的功能API，不提供测试；测试厂商来完成测试方面（第三方架包，类库） 1.导入类库junit4.9 2.测试方法（必须无返回值，无参数）如果有返回值和参数，在定义一个测试方法包裹一下 File类获得文件夹中的文件public void addFile() { //创建一个文件;1.绝对路径（不建议，路径与项目无关，如果路径修改，需要变动的地方太多） File file = new File(&quot;上传文件&quot;);//在项目的路径下创建一个文件，与src目录同级 //2.相对路径：相对项目的路径 file.mkdirs(); } @Test public void deleteFile() { File file = new File(&quot;上传文件&quot;); file.delete(); } //文件夹的读取 @Test public void show() { File file = new File(&quot;src&quot;); File[] files = file.listFiles();//孩子 for(File child:files) { System.out.println(child.getName()); } } @Test public void showAll(String fileName) { File file = new File(fileName); System.out.println(file.getName()); File[] files = file.listFiles();//孩子 //出口 if(files.length==0) { //空 return; } for(File child:files) { //判断孩子是文件还是文件夹 if(child.isFile()) { //文件 System.out.println(child.getName()); }else { //文件夹，以相同的方式遍历，不断地缩短问题 showAll(child.getAbsolutePath()); } } } @Test public void testshowAll() { showAll(&quot;MacOS:\\Users\\gf&quot;); } public void remove(String name) { File file = new File(name); File[] files = file.listFiles(); if(files.length==0) { file.delete(); }else { //不为空，先删除孩子 for(File child:files) { if(child.isFile()) { child.delete(); }else { //如果孩子是文件夹以相同的方式处理 remove(child.getAbsolutePath()); } } } if(file.exists()){ file.delete();//如果还存在，删除自己 } } 在java里面设备与设备之间的信息传输都是以流的形式 小说：发给你视频：发给你 单位：计算机以什么单位存储 字节 8bit 8个01组成 小说，一个个字节发给你：网络 1m=1024kb 1kb=1024b 中文乱码：####设备与设备之间的传输问题 中文不是一个字节，是多个字节 ##编码方式： ASCII:一个字节，存储字母，表达的东西比较少 Unicode：2个字节 前一个字节是ASCII,后面是补充（中文）2个字节存储还是有限 utf-8：三个字节，存储中文，一个中文三个字节 GBK：表示中文，一个中文两个字节]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F03%2F%E6%9C%AA%E5%91%BD%E5%90%8D2%2F</url>
    <content type="text"><![CDATA[学生：姓名，数学成绩，语文成绩，英语成绩 要求总分排序，从低到高， 如果总分相等，按数学成绩排序，数学成绩相等，语文成绩排序，语文成绩相等，按姓名排序 将一个对象]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F03%2F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[###缺陷：底层是数组，需要空间连续并且数组在实例化时需要长度，那么内存空间可能长时间浪费 改进：数据不存在一起（物理分离），逻辑上是连续的##链式，链表 如果添加和删除比较频繁使用LinkedList（出库入口）数据量大的时候 如果查询比价频繁，使用Arraylist（员工系统） List是一个可以存储重复数据的集合，并且能够根据特定的位置去存储和获取数据]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F02%2FJava%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Java日期时间java.util提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象 Date(); //使用当前的日期和时间来初始化对象 Date(long millisec); //接受一个参数，该参数是从1970年1月1日起的毫秒数。 Date对象创建后可以调用如下方法： boolean after(Date date) 调用此方法的Date对象在指定日期之后返回true，否则false boolean before(Date date)调用此方法的Date对象在指定日期之前返回false，否则true Object clone() 返回此对象的副本 int compareTo(Date date) 比较调用此方法的Date对象和指定日期相等返回零。调用对象在指定日期之前返回负数，在指定日期之后返回正数 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date date),否则抛出ClassCastException boolean equals(Object date)当调用此方法的Date对象和指定日期相等返回true，否则返回false long getTime() 返回自1970年开始此Date对象表示的毫秒数 int hashCode()返回此对象的哈希值 void setTime(long time) 用自1970开始的毫秒数设置日期和时间 String toString()把此Date对象转换成以下形式的string：dow mon dd hh:mm:ss zzz yyyy 其中：dow是一周中的某一天（sun，mon，tue，wed，thu，fri，sat） 获取当前日期和时间java中获取当前日期和时间，使用Date对象的toString()方法来打印当前日期和时间12345678import java.util.Date;public class DateDemo&#123; public static void main(String args[])&#123; Date date = new Date(); //使用toString()函数显示日期时间 System.out.println(date.toString()); &#125;&#125; 日期比较java使用以下三种方法来比较两个日期： 使用getTime()方法来获取两个日期，比较这两个值； 使用方法before（），after（），equals（）。 使用compareTo（）方法，它是由Comparable接口定义的，Date类实现了这个接口 使用SimpleDateFormat格式化日期SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期时间格式来运行。123456789import java.util.*;import java.text.*;public class DateDemo&#123; public static void main(String[] args)&#123; Date dNow = new Date(); SimpleDateFormat ft = new SimpleDateFormat(&quot;E yyyt.MM.dd &apos;at&apos; hh:mm:ss a zzz&quot;); System.out.println(&quot;Current Date:&quot;+ft.format(dNow)); &#125;&#125; 日期和时间的格式化编码 时间模式字符串用来指定时间格式。在此模式中，所有的ASCII字母被保留为模式字母，定义如下： 使用print格式化日期]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F02%2F%E6%9C%AA%E5%91%BD%E5%90%8D1%2F</url>
    <content type="text"><![CDATA[日期 Date SimpleDateFormat Date格式化 format字符串 Canlender 抽象类 Canlender cal = new Canlender.getInstance();是他的子类对象 日期的计算 add() set() get() Canlender-&gt;Date getTime() Date-&gt;Canlender setTime(Date) 输入任何年，输出该年2月是多少天 思路： 3.1-1 get 闰年： 3.1 -1 2.29 不是闰年： 3.1-1 2.28数组：1.里面只能存放相同数据类型的数据元素2.数组定长3.数组只是一个数据类型，没有过多方法，对于多个数据元素之间操作；增删改查没有方法，需要我们手动编写对于一个容器的操作，重复的操作，Java考虑到了Java提供了这一系列的类：集合框架类 这个类一定是个抽象类或接口，绝对是集合框架的根，集合框架继承体系]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F01%2F%E5%85%AB%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E6%AF%94byte%20short%20int%20long%20char%20double%20float%20Boolean%2F</url>
    <content type="text"><![CDATA[八个基本数据类型 比byte short int long char double float Boolean基本数据类型-&gt;包装类]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F31%2F%E6%9C%AA%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[StringBuffer 线程安全的可变字符序列，效率慢 jdk1.0 StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。 1.字符串序列拼接，拼接到尾部append（数据）insert（int offset，插入的数据）delete（int start，int end）deleteCharAt（int index） 2.返回长度int capacity（）返回当前容量int length（）返回长度（字符数） 3.查找 char charAt（int index） int indexOf（String str）返回第一次出现的指定子字符串在该字符串中的索引 int lastIndexOf（String str） 4.其他StringBuffer reverse（）将此字符序列用其反转形式取代replace（int start，int end。String str） 使用给定String中的字符替换此序列中的子字符串中的字符 StringBuilder 一个可变的字符序列，效率快 jdk1.5 StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 string stringbuffer stringbuilder区别： string字符串常量一旦定义内容不可变 buffer线程安全 builder线程不安全]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F31%2F%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) import java.util.Scanner; /* 需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) 举例： “Hello123World” 结果： 大写字符：2个 小写字符：8个 数字字符：3个 分析： 前提：字符串要存在 A:定义三个统计变量 bigCount=0 smallCount=0 numberCount=0 B:遍历字符串，得到每一个字符。 length()和charAt()结合 C:判断该字符到底是属于那种类型的 大：bigCount++ 小：smallCount++ 数字：numberCount++ 这道题目的难点就是如何判断某个字符是大的，还是小的，还是数字的。 ASCII码表： 0 48 A 65 a 97 虽然，我们按照数字的这种比较是可以的，但是想多了，有比这还简单的 char ch = s.charAt(x); if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’) numberCount++ if(ch&gt;=’a’ &amp;&amp; ch&lt;=’z’) smallCount++ if(ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’) bigCount++ D:输出结果。* 练习：把给定字符串的方式，改进为键盘录入字符串的方式。*/public class StringTest2 {public static void main(String[] args) {//定义一个字符串Scanner sc =new Scanner(System.in);System.out.println(“请输入一个字符串”);String name=sc.nextLine();//定义三个统计变量int bigCount = 0;int smallCount = 0;int numberCount = 0; //遍历字符串，得到每一个字符。for(int x=0; x&lt;name.length(); x++){char ch = name.charAt(x); //判断该字符到底是属于那种类型的if(ch&gt;=’a’ &amp;&amp; ch&lt;=’z’){smallCount++;}else if(ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’){bigCount++;}else if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’){numberCount++;}} //输出结果。System.out.println(“大写字母”+bigCount+”个”);System.out.println(“小写字母”+smallCount+”个”);System.out.println(“数字”+numberCount+”个”);}}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Day05]]></title>
    <url>%2F2018%2F07%2F31%2FDay05%2F</url>
    <content type="text"><![CDATA[OPP和OOP的区别：OPP过程开发：程序和程序运行过程一致，从上而下分析业务编写代码OOP面向对象开发：提取能够完成业务功能的对象，然后相互合作 类和对象区别：类是抽象的模板；对象是类的实体 ####数组的特点： 1. 只能存储同一种数据类型的数据。 2. 一旦初始化，长度固定。 3. 数组中的元素与元素之间的内存地址是连续的。 setter和getter方法的作用：封装数据，对私有属性进行封装，只是暴露出public方法来访问。但是为什么要这么做，原因很简单，封装的作用就是保护，保护属性本身不被篡改。 比如有些属性只是可读但不可写，那么只提供它的getter方法就好，意思就是某些属性只能单一方向的被访问， getter和setter就是提供这样的接口，对于public的属性，可以直接使用类名来访问，自身的“安全性”就降低了。 toString方法的作用：返回该对象的字符串表示。通常， toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 简述对象实例化的过程： 1、 如果存在继承关系，就先父类后子类； 2 、如果在类内有静态变量和静态块，就先静态后非静态，最后才是构造函数； 3 、继承关系中，必须要父类初始化完成后，才初始化子类。 函数的重载：多个函数的名字相同，但是形参列表不同(参数类型不同或参数个数不同)，返回值类型可同也可不同，我们称之为重载函数。重载的函数是通过形参列表区分的，与返回值类型无关。 不定参数的格式： 第一，方法的参数列表中最多只有一个不定长度的参数； 第二，就是不定长度的数组的位置必须是最后一个参数。不然不能通过编译。 参数的类型相同，只是参数的个数不定 构造方法的要求及作用：没有返回值，方法和类同名；没有jvm会默认添加无参的构造创建和初始化对象；]]></content>
      <tags>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承;2C]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BB%A7%E6%89%BF-2C%2F</url>
    <content type="text"><![CDATA[继承继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类， 多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类， 这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 implements关键字使用 implements 关键字可以变相的使java具有多继承的特性， 使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写 构造器 子类不能继承父类的构造器（构造方法或者构造函数） 如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。]]></content>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaAPI]]></title>
    <url>%2F2018%2F07%2F31%2FJavaAPI%2F</url>
    <content type="text"><![CDATA[JavaAPIjava默认的包是Java.lang = language Java语言包，该包下的所有类使用无需导入包，否则需要！ Object类是层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。 子类都可以重写父类的方法，意味着任何类都可以继承或重写object的所有方法除非（final，private） 1Object（）无参构造，即默认的构造方法 数组里只能存放相同的数据元素-&gt;解决办法：1Object[] arrs = &#123;1,2.0,&quot;你好&quot;,new Date(),false&#125;; 原理：多态，子父类方法摘要protected Object clone() 12345 boolean equals(Object obj) **equals（）是一个方法只有对象才可以调用** ```指示其他某个对象是否与此对象“相等”。 String toString() 默认可以省去，一般子类会重写toString方法来输出属性值 变量拼接，先开辟空间，再拼接 1234567 **字符串在字符串常量池里， String缺陷在做字符串拼接的时候，反复的开辟和销毁空间** #### 1.protected void finalize() ```当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃 圾回收器调用此方法。 2.Class&lt;?&gt; getClass() Object 的运行时类。```1234 #### 3.int hashCode() ``` 返回该对象的哈希码值。 4.void notify() 1234 #### 5.void notifyAll() ``` 唤醒在此对象监视器上等待的所有线程。 6.void wait() notify() 方法或 notifyAll() 方法前，导致当前线程等待。```1234 #### 7.void wait(long timeout) ```在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 8.void wait(long timeout, int nanos) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。]]></content>
      <tags>
        <tag>JavaAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的方法]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串的方法1.基本数据类型转成字符串的方法valueOf()static String valueOf(boolean b) boolean 参数的字符串表示形式。```123 static String valueOf(char c) ``` 返回 char 参数的字符串表示形式。 static String valueOf(char[] data) char 数组参数的字符串表示形式。```123 static String valueOf(char[] data, int offset, int count) ```返回 char 数组参数的特定子数组的字符串表示形式。 static String valueOf(double d) double 参数的字符串表示形式。```123 static String valueOf(float f) ``` 返回 float 参数的字符串表示形式。 static String valueOf(int i) int 参数的字符串表示形式。```123 static String valueOf(long l) ``` 返回 long 参数的字符串表示形式。 static String valueOf(Object obj) Object 参数的字符串表示形式。```1234 ### 2.截取方法 String substring(int beginIndex) ``` 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 12 **代码：** public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。示例： “hamburger”.substring(4, 8) returns “urge” “smiles”.substring(1, 5) returns “mile” 12345678910111213141516171819202122232425262728293031323334353637参数：beginIndex - 起始索引（包括）endIndex - 结束索引（不包括）。返回：指定的子字符串。抛出：IndexOutOfBoundsException - 如果 beginIndex 为负，或 endIndex 大于此 String 对象的长度，或 beginIndex 大于 endIndex。 ### 3.查找#### indexOf 第一次出现的位置#### lastIndexOf 最后一次出现的位置#### boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 #### boolean contains(CharSequence s) 当且仅当此字符串包含指定的 char 值序列时，返回 true。 #### int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。#### char charAt(int index) 返回指定索引处的 char 值。 * int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 * int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 * int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 String str = “”; int count = 0; while(str.length()&gt;0){ int index = str.indexOf(“java”); if(index&gt;=0){ count++; str = str.substring(index+4); }else{ break } } System.out.println(count+”次”); 1234567891011121314151617181920## 4.大小写的问题（）* 1.boolean equals(Object anObject) 将此字符串与指定的对象比较。* 2.boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。* 3.String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。* 4.String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。###问题：输入字符串，把一个字符串的首字符转为大写**代码：** public class UpperAndLower{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(“请输入字符串：”); String string = scanner.next().trim();//去掉前面所有和后面所有的空格 String newString = string.substring(0,1).toupperCase()+string.substring(1).toLowerCase(); System.out.println(“newString”); }}` 5.其他 String trim(): 返回字符串的副本，忽略前导空白和尾部空白。 String[] split(String regex) :根据给定正则表达式的匹配拆分此字符串。 int compareTo(String anotherString) :按字典顺序比较两个字符串。 int compareToIgnoreCase(String str) : 按字典顺序比较两个字符串，不考虑大小写。 String replace(char oldChar, char newChar) :返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。]]></content>
      <tags>
        <tag>字符串的方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念一]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%A6%82%E5%BF%B5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[面向对象：1.什么是oopOOP：Object Oriented Programming;面向对象的程序设计。所谓“对象“在显示支持面向对象的语言中，一般是指类在内存中装载的实例，具有相关的成员变量和成员函数（方法）。面对对象的程序设计完全不同于传统的面向过程程序设计，它大大降低了软件开发的难度。 OOP达到了软件工程的三个主要目标：重用性，灵活性和拓展性； 2.重写和重载的区别重写：子类定义的方法与父类中的方法具有相同的方法名字，相同的参数表和返回类型： 子类中不能重写父类中的final方法 子类中必须重写父类的abstract方法重载：同一个类中的多个方法具有相同的名字，但这些名字具有不同的参数列表，即参数的数量和参数类型不能完全相同 3.接口和实现类的区别接口（interface）在Java语言中就是一个抽象类型，但接口不是抽象类，是抽象方法的集合。类通过继承接口的方式来继承接口的抽象方法。 接口无法被实例化，但是可以被实现；一个实现接口的类必须实现接口内描述的所有方法，否则必须声明为抽象类。 4.简述staticstatic方法就是没有this的方法，在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来条用static方法。这实际上就是static方法的主要用途。 方便在没有创建对象的时候调用（方法/变量） 5.简述final关键字可以修饰类，方法和变量（包括成员变量和局部变量） 6.一个实体类实例化的对象的过程1.递归的在堆中首先创建其父类对象，调用父类构造方法。 2.创建对象自己，执行构造方法实例化。 3.Java中类的构造方法默认第一行都是super（），即调用父类构造方法。 4.在对象的实例化过程中，若类中有代码块或静态代码块，代码块是先于构造方法执行的 7.什么是多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是一个接口，使用不同的实例执行不同的操作。 优点： 1.消除类型之间的耦合关系 2.可替换性 3.可扩充性 4.接口性 5.灵活性 6.简化性 存在条件 继承 重写 父类引用指向子类对象 8.向上转型和向下转型需要注意哪些向上转型：子类引用的对象转换成父类类型 减少重复代码，使代码简洁 提高系统扩展性 向下转型：父类对象转为子类对象注意事项 前提是父类对象指向的是子类对象（也就是要先向上转型） 只能转型为本类对象 9.面向对象的特征有哪些 抽象 封装 多态 继承 10.说说你熟悉的设计模式 单例 工厂 模板 11.this和super的区别首先不可同时出现；都位于第一行 this用于同一个类中从某个构造函数调用另一个重载版的构造函数 super用于在子类构造函数中调用父类的构造函数 12.匿名内部类如何使用匿名内部类定义假如一个局部内部类只被用一次（只用它构建一个对象），就可以不用对其命名了，这种没有名字的类被称为匿名内部类（anonymous inner class），其代码格式通常为：123new SuperType(construction parameters)&#123; inner class methods and data&#125;; 匿名内部类的构造器 由于构造器的名字必须与类名相同，而匿名内部类没有类名，所以匿名类不能含有构造器。取而代之的是将构造器参数传递给超类（superclass）的构造器。 当匿名类实现某个接口的时候，一定不能存在任何构造参数。这时，代码格式构成变成如下所示：123new InterfaceType()&#123; methods and data&#125;;]]></content>
      <tags>
        <tag>面试概念总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式与工厂模式与模板模式]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例：最多一个实例对象工厂模式：所有对象都由工厂生产（静态工厂）模板模式：父类定义好了算法步骤，对于每个步骤的具体实现由子类来实现，通过多态的方式，根据具体子类来完成具体的算法步骤。例子：做菜（提取模板来约束）： 配备食材（不同的菜食材不一样） 切菜 烧菜 //模板设计模式 public abstract class Cook { //设计模板 public abstract void ready(); //1 public abstract void wash(); //2 public abstract void cook(); //3 //统一规范 public final void cookFull() { //固定模板，禁止子类修改 ready(); wash(); cook(); } } 番茄鸡蛋 public class TomatoAndEgg extends Cook { @Override public void ready() { // TODO Auto-generated method stub System.out.println(&quot;准备番茄鸡蛋&quot;); } // @Override public void wash() { // TODO Auto-generated method stub System.out.println(&quot;洗番茄鸡蛋&quot;); // } // @Override public void cook() { // TODO Auto-generated method stub System.out.println(&quot;做番茄鸡蛋&quot;); } } main方法 public class Test { public static void main(String[] args) { //模板类：父类优先定义好骨架模板final，不能被修改；具体的实现细节，推迟到给子类实现 Cook cook = new TomatoAndEgg(); cook.cookFull();//模板（执行步骤，父类一定要统一） } } 策略模式：不同用户的策略不一样，不同的环境来选择查找算法为例： 顺序查找 二分查找]]></content>
      <tags>
        <tag>Java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型的取值范围1.byte：一个字节是八个二进制位，由于Java中有任何无符号类型，所以在八个二进制位里面有一个是符号位，7个是数值位；原码：最高位是符号位，0为正，1为负，其余位表示数值的大小； 反码：正数的反码与其原码相同，负数的反码是在其原码逐位取反，但符号位除外； 补码：正数的补码与其原码相同，负数的补码是在反码末尾加一（符号位也算计数位）； 最小数是 1 000 0000 先减一 0 111 1111 按位取反1 000 0000 = 128 byte(字节类型)一个byte 8位，取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）默认是0 short(短整型)一个short 16位，取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）默认是0 int(整型)一个int 32位，取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）默认是0 long(长整型)一个long 64位,取值范围为（-9223372036854774808~9223372036854774807）,占用8个字节（-2的63次方到2的63次方-1）默认是0L]]></content>
      <tags>
        <tag>Java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2018%2F07%2F29%2FMarkdown%2F</url>
    <content type="text"><![CDATA[MacDownHello there! I’m MacDown, the open source Markdown editor for OS X. Let me introduce myself. Markdown and IMarkdown is a plain text formatting syntax created by John Gruber, aiming to provide a easy-to-read and feasible markup. The original Markdown syntax specification can be found here. MacDown is created as a simple-to-use editor for Markdown documents. I render your Markdown contents real-time into HTML, and display them in a preview panel. I support all the original Markdown syntaxes. But I can do so much more! Various popular but non-standard syntaxes can be turned on/off from the Markdown preference pane. You can specify extra HTML rendering options through the Rendering preference pane. You can customize the editor window to you liking in the Editor preferences pane: You can configure various application (that’s me!) behaviors in the General preference pane. The BasicsBefore I tell you about all the extra syntaxes and capabilities I have, I’ll introduce you to the basics of standard markdown. If you already know markdown, and want to jump straight to learning about the fancier things I can do, I suggest you skip to the Markdown preference pane. Lets jump right in. Line BreaksTo force a line break, put two spaces and a newline (return) at the end of the line. This two-line bulletwon’t break This two-line bulletwill break Here is the code: 12345* This two-line bullet won&apos;t break* This two-line bullet will break Strong and EmphasizeStrong: **Strong** or __Strong__ (Command-B)Emphasize: *Emphasize* or _Emphasize_[^emphasize] (Command-I) Headers (like this one!)Header 1 ======== Header 2 -------- or # Header 1 ## Header 2 ### Header 3 #### Header 4 ##### Header 5 ###### Header 6 Links and EmailInlineJust put angle brackets around an email and it becomes clickable: &#x75;&#x72;&#97;&#110;&#x75;&#x73;&#106;&#114;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;&lt;uranusjr@gmail.com&gt; Same thing with urls: http://macdown.uranusjr.com&lt;http://macdown.uranusjr.com&gt; Perhaps you want to some link text like this: Macdown Website[Macdown Website](http://macdown.uranusjr.com &quot;Title&quot;) (The title is optional) Reference styleSometimes it looks too messy to include big long urls inline, or you want to keep all your urls together. Make a link [a link][arbitrary_id] then on it’s own line anywhere else in the file:[arbitrary_id]: http://macdown.uranusjr.com &quot;Title&quot; If the link text itself would make a good id, you can link like this [like this][], then on it’s own line anywhere else in the file:[like this]: http://macdown.uranusjr.com ImagesInline![Alt Image Text](path/or/url/to.jpg &quot;Optional Title&quot;) Reference style![Alt Image Text][image-id]on it’s own line elsewhere:[image-id]: path/or/url/to.jpg &quot;Optional Title&quot; Lists Lists must be preceded by a blank line (or block element) Unordered lists start each item with a * - works too Indent a level to make a nested list Ordered lists are supported. Start each item (number-period-space) like 1. It doesn’t matter what number you use, I will render them sequentially So you might want to start each line with 1. and let me sort it out Here is the code: 12345678* Lists must be preceded by a blank line (or block element)* Unordered lists start each item with a `*`- `-` works too * Indent a level to make a nested list 1. Ordered lists are supported. 2. Start each item (number-period-space) like `1. ` 42. It doesn&apos;t matter what number you use, I will render them sequentially 1. So you might want to start each line with `1.` and let me sort it out Block Quote Angle brackets &gt; are used for block quotes.Technically not every line needs to start with a &gt; as long asthere are no empty lines between paragraphs.Looks kinda ugly though. Block quotes can be nested. Multiple Levels Most markdown syntaxes work inside block quotes. Lists Links Etc. Here is the code: 123456789101112&gt; Angle brackets `&gt;` are used for block quotes. Technically not every line needs to start with a `&gt;` as long asthere are no empty lines between paragraphs. &gt; Looks kinda ugly though.&gt; &gt; Block quotes can be nested. &gt; &gt; &gt; Multiple Levels&gt;&gt; Most markdown syntaxes work inside block quotes.&gt;&gt; * Lists&gt; * [Links][arbitrary_id]&gt; * Etc. Inline CodeInline code is indicated by surrounding it with backticks:`Inline code` If your code has `backticks` that need to be displayed, you can use double backticks:``Code with `backticks` `` ```` (mind the spaces preceding the final set of backticks)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950### Block CodeIf you indent at least four spaces or one tab, I&apos;ll display a code block. print(&apos;This is a code block&apos;) print(&apos;The block must be preceded by a blank line&apos;) print(&apos;Then indent at least 4 spaces or 1 tab&apos;) print(&apos;Nesting does nothing. Your code is displayed Literally&apos;)I also know how to do something called [Fenced Code Blocks](#fenced-code-block) which I will tell you about later.### Horizontal RulesIf you type three asterisks `***` or three dashes `---` on a line, I&apos;ll display a horizontal rule:***## &lt;a name=&quot;markdown-pane&quot;&gt;&lt;/a&gt;The Markdown Preference PaneThis is where I keep all preferences related to how I parse markdown into html. ![Markdown preferences pane](http://d.pr/i/RQEi+)### Document FormattingThe ***Smartypants*** extension automatically transforms straight quotes (`&quot;` and `&apos;`) in your text into typographer’s quotes (`“`, `”`, `‘`, and `’`) according to the context. Very useful if you’re a typography freak like I am. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence.### Block Formatting#### TableThis is a table:First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content CellYou can align cell contents with syntax like this:| Left Aligned | Center Aligned | Right Aligned ||:------------- |:---------------:| -------------:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |The left- and right-most pipes (`|`) are only aesthetic, and can be omitted. The spaces don’t matter, either. Alignment depends solely on `:` marks.#### &lt;a name=&quot;fenced-code-block&quot;&gt;Fenced Code Block&lt;/a&gt;This is a fenced code block: print(‘Hello world!’)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071You can also use waves (`~`) instead of back ticks (`` ` ``):~~~print(&apos;Hello world!&apos;)~~~You can add an optional language ID at the end of the first line. The language ID will only be used to highlight the code inside if you tick the ***Enable highlighting in code blocks*** option. This is what happens if you enable it:![Syntax highlighting example](http://d.pr/i/9HM6+)I support many popular languages as well as some generic syntax descriptions that can be used if your language of choice is not supported. See [relevant sections on the official site](http://macdown.uranusjr.com/features/) for a full list of supported syntaxes.### Inline FormattingThe following is a list of optional inline markups supported:Option name | Markup | Result if enabled |--------------------|------------------|-----------------------|Intra-word emphasis | So A\*maz\*ing | So A&lt;em&gt;maz&lt;/em&gt;ing |Strikethrough | \~~Much wow\~~ | &lt;del&gt;Much wow&lt;/del&gt; |Underline [^under] | \_So doge\_ | &lt;u&gt;So doge&lt;/u&gt; |Quote [^quote] | \&quot;Such editor\&quot; | &lt;q&gt;Such editor&lt;/q&gt; |Highlight | \==So good\== | &lt;mark&gt;So good&lt;/mark&gt; |Superscript | hoge\^(fuga) | hoge&lt;sup&gt;fuga&lt;/sup&gt; |Autolink | http://t.co | &lt;http://t.co&gt; |Footnotes | [\^4] and [\^4]: | [^4] and footnote 4 |[^4]: You don&apos;t have to use a number. Arbitrary things like `[^footy note4]` and `[^footy note4]:` will also work. But they will *render* as numbered footnotes. Also, no need to keep your footnotes in order, I will sort out the order for you so they appear in the same order they were referenced in the text body. You can even keep some footnotes near where you referenced them, and collect others at the bottom of the file in the traditional place for footnotes. ## &lt;a name=&quot;rendering-pane&quot;&gt;&lt;/a&gt;The Rendering Preference PaneThis is where I keep preferences relating to how I render and style the parsed markdown in the preview window. ![Rendering preferences pane](http://d.pr/i/rT4d+)### CSSYou can choose different css files for me to use to render your html. You can even customize or add your own custom css files.### Syntax HighlightingYou have already seen how I can syntax highlight your fenced code blocks. See the [Fenced Code Block](#fenced-code-block) section if you haven’t! You can also choose different themes for syntax highlighting.### TeX-like Math SyntaxI can also render TeX-like math syntaxes, if you allow me to.[^math] I can do inline math like this: \\( 1 + 1 \\) or this (in MathML): &lt;math&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;, and block math:\\[ A^T_S = B\\]or (in MathML)&lt;math display=&quot;block&quot;&gt; &lt;msubsup&gt;&lt;mi&gt;A&lt;/mi&gt; &lt;mi&gt;S&lt;/mi&gt; &lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mi&gt;B&lt;/mi&gt;&lt;/math&gt;### Task List Syntax1. [x] I can render checkbox list syntax * [x] I support nesting * [x] I support ordered *and* unordered lists2. [ ] I don&apos;t support clicking checkboxes directly in the html window### Jekyll front-matterIf you like, I can display Jekyll front-matter in a nice table. Just make sure you put the front-matter at the very beginning of the file, and fence it with `---`. For example: title: “Macdown is my friend” date: 2014-06-06 20:00:00` Render newline literallyNormally I require you to put two spaces and a newline (aka return) at the end of a line in order to create a line break. If you like, I can render a newline any time you end a line with a newline. However, if you enable this, markdown that looks lovely when I render it might look pretty funky when you let some other program render it. The General Preferences PaneThis is where I keep preferences related to application behavior. The General Preferences Pane allows you to tell me how you want me to behave. For example, do you want me to make sure there is a document open when I launch? You can also tell me if I should constantly update the preview window as you type, or wait for you to hit command-R instead. Maybe you prefer your editor window on the right? Or to see the word-count as you type. This is also the place to tell me if you are interested in pre-releases of me, or just want to stick to better-tested official releases. The Editor Preference PaneThis is where I keep preferences related to the behavior and styling of the editing window. StylingMy editor provides syntax highlighting. You can edit the base font and the coloring/sizing theme. I provided some default themes (courtesy of Mou’s creator, Chen Luo) if you don’t know where to start. You can also edit, or even add new themes if you want to! Just click the Reveal button, and start moving things around. Remember to use the correct file extension (.styles), though. I’m picky about that. I offer auto-completion and other functions to ease your editing experience. If you don’t like it, however, you can turn them off. Hack OnThat’s about it. Thanks for listening. I’ll be quiet from now on (unless there’s an update about the app—I’ll remind you for that!). Happy writing! [^emphasize]: If Underlines is turned on, _this notation_ will render as underlined instead of emphasized [^under]: If Underline is disabled _this_ will be rendered as emphasized instead of being underlined. [^quote]: Quote replaces literal &quot; characters with html &lt;q&gt; tags. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence. Note that Quote is different from blockquote, which is part of standard Markdown. [^math]: Internet connection required.]]></content>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
</search>
