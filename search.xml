<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[复习4]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%8D%E4%B9%A04%2F</url>
    <content type="text"><![CDATA[1.策略模式 2.模板模式 3.什么是继承 4.final ,finalize,finally区别 5.局部变量,成员变量和静态变量的区别 6.String StringBuffer StringBuilder 7.String和基本数据之间转换的规则 8.String常用的构造方法 9.什么是装箱和拆箱 10.什么是枚举,如何定义]]></content>
  </entry>
  <entry>
    <title><![CDATA[复习3]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%8D%E4%B9%A03%2F</url>
    <content type="text"><![CDATA[1.List和Set的区别 2.AarrayList和vector的区别 3.LinkedList和AarrayList的区别 4.比较器排序和自然排序的区别 5.Hashtble和HashMap的区别 6.什么是泛型 7.说出几个常用的异常 8.运行时异常和编译异常的区别 9.String里面常用的方法 10.正则中?和* 的区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[复习2]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%8D%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[1.break和continue的区别break有时候我们想在某种条件出现的时候终止循环而不是等到循环条件为false才终止。 这时我们可以使用break来完成。break用于完全结束一个循环，跳出循环体执行循环后面的语句。 continuecontinue和break有点类似，区别在于continue只是终止本次循环，接着还执行后面的循环，break则完全终止循环。 可以理解为continue是跳过当次循环中剩下的语句，执行下一次循环。 2.String和StringBuilder的区别String 对象是不可改变的。每次使用 System.String 类中的方法之一时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。 例如： string a=”a”;a+=”b”;,每次在后面追加都会重新申请一个能放字符串的内存空间； string Interning(字符串驻留)指的是通过维护一张表来存放字符串。CLR内部维护了一个哈希表（Hash Table）来管理其创建的大部分string对象，其中key为string本身，而value为分配给对应string的内存地址。 public static string Intern(string str); public static string IsInterned(string str); 两者的处理机制都是在哈希表中查找是否存在str参数字符串，如果找到就返回已存在的string对象的引用，没有找到，Intern方法将该str字符串添加到哈希表，并返回引用；而IsInterned方法则不会向哈希表中添加字符串，而是返回null; StringBuilder 对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值，当修改 StringBuilder 时，在达到容量之前，它不会为其自己重新分配空间。当达到容量时，将自动分配新的空间且容量翻倍。可以使用重载的构造函数之一来指定 StringBuilder 类的容量。 例如： StringBuilder sb = new StringBuilder(); sb.Append(&quot;a&quot;) 他不会频繁申请内存空间，他会自动向后扩展。 两者的区别： 1.string 对象时恒定不变的，stringBuider对象表示的字符串是可变的。stringBuilder是.net提供的动态创建string的高效方式，以克服string对象恒定性带来的性能影响。 2.对于简单的字符串连接操作，在性能上stringBuilder并不一定总是优于string。因为stringBuider对象创建代价较大，在字符串目标连接较少的情况下，过度滥用stringBuilder会导致性能的浪费，只有大量的或者无法预知次数的字符串操作，才考虑stringBuilder来实现。事实上，一般连接次数设置100次以内，根本看不出两者的性能差别。 3.当修改字符串信息时，此时不许创建对象，可以使用stringBuilder对象。 3.类名是否一定要和文件名同名包含main方法的类一定要同名 4.char占几个字节两个字节 5.有哪几种访问修饰符，范围是什么privateprotectedpublic 6.如果想跳出多层循环，应该怎么办7.如果catch里面有return返回值，finally是否执行，什么时候执行结论： 1、不管有没有异常，try和catch中有没有return，finally都会执行。 2、finally不会影响返回值，返回值在进入finally之前已经确定，存放在内存中。 3、finally是在return表达式之后执行（此时，返回值=（表达式的值）已经存放在内存中），执行完finally之后，最后：return返回值。 8.Java中内存能否直接回收，Java垃圾回收原理。9.两个整型变量i和j,不用中间变量进行交换。int i = i+j;;i=i-j;j=i-j; 10.面向对象的特征有哪些方面。 封装 多态 继承 11.字节符和字符流的区别12.常用的字节流有哪些13.如何创建文件和文件夹]]></content>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习1]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%A4%8D%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[1.抽象类和接口区别抽象类里面普通类里面有的方法和属性，也可以有抽象方法； 而接口里面只能有public修饰的抽象方法和public static final修饰的属性。 内部成员 实例化 3.类单继承,接口多继承 4.类多实现接口 2.匿名内部类接口实现类对像或者抽象类的子类对象,编写方便,一次使用 3.局部内部类调用局部变量的注意点final修饰局部变量,提高局部变量的生命周期 4.什么多态父类引用指向子类对象。 接口引用指向实现类对象 5.向上转型和向下转型向上转型 -&gt;多态,可以直接转型 向下转型只能强制转,注意如果真实对象不是该类型,会报错 6.单例模式一个类只能实例化一个对象，在类中构造方法私有化，一个自己类型的私有的静态的对象，然后通过get方法让外部获得。 7.静态工厂模式专门负责实例化对象,每个获得对象的方法都是静态的,直接类名.***调用该方法 8.abstract和哪些关键字冲突 final private static 10.如何判断某个对象是否属于哪个数据类型instance of]]></content>
      <tags>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection接口]]></title>
    <url>%2F2018%2F08%2F11%2FCollection%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[数组： 1.里面只能存放相同数据类型的数据元素 2.数组定长 3.数组只是一个数据类型，没有过多方法，对于多个数据元素之间操作：增删修改没有方法，需要我们手动的编写 那么对于一个容器的操作，重复的增删改查 ，java绝对考虑到了 java提供了这一系列的类：集合框架类：不是一个类，是多个类 因为容器里面很多方法是共同的，提取多来，规定容器必须具备哪些方法 这个类抽象类或者接口，绝对是集合框架的根，集合框架继承体系 public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; Collection 层次结构 中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。 JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection public interface List&lt;E&gt; extends Collection&lt;E&gt; 列表：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。特点：有序：能够根据插入的位置找到该元素，能够存放重复的数据 实现类： public class ArrayList&lt;E&gt; ：List 接口的大小可变数组的实现。 ArrayList() 构造一个初始容量为 10 的空列表。ArrayList(int initialCapacity) 构造一个具有指定初始容量的空列表。boolean add(E e) 将指定的元素添加到此列表的尾部。void add(int index, E element) 将指定的元素插入此列表中的指定位置。 void clear() 移除此列表中的所有元素。 E remove(int index) 移除此列表中指定位置上的元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。protected void removeRange(int fromIndex, int toIndex) 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 E get(int index) 返回此列表中指定位置上的元素。 int indexOf(Object o) 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。 boolean isEmpty() 如果此列表中没有元素，则返回 true int lastIndexOf(Object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。 int size() 返回此列表中的元素数。 数组 length String length（） 集合 size（） ArrayList线程不安全 public class Vectorextends AbstractListimplements List, RandomAccess, Cloneable, SerializableVector 类可以实现可增长的对象数组。 缺陷：底层是数组，需要空间连续并且数组在实例化时需要长度，那么内存空间可能长时间浪费 改进：数据不存在一起（物理分离），没有的数据，不开辟空间 1号 2号 3号 逻辑是连续的 1号+2号的地址 2号+3号 3号数据+4号 4号 public class LinkedList List 接口的链接列表实现。不安全 void addFirst(E e) 将指定元素插入此列表的开头。 void addLast(E e) 将指定元素添加到此列表的结尾。 E getFirst() 返回此列表的第一个元素。 E getLast() 返回此列表的最后一个元素。 E peekFirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。 E peekLast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。 E pollFirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。 E pollLast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。 E removeFirst() 移除并返回此列表的第一个元素。 E removeLast() 移除并返回此列表的最后一个元素。 //底层的增删改查的时间复杂度，什么时候用ArrayList，什么时候用LinkedList 1，ArrayList的空间复杂度会比LinkedList，会存在空间浪费 如果查询比较频繁，使用ArrayList （员工系统） 如果添加和删除比较频繁：LinkedList （出库入口），数据量大的时候 List总结： List是一个可以存储重复数据的集合，并且能够根据特定的位置去存储和获取数据 往LinkedList里面存储1,2,3,4,5,6 Integer 然后 1,2,3 追加 4,插入到头部，5插入到尾部，6追加 然后用Interator迭代器遍历 删除头部 删除第2个数据元素 用增强for循环遍历 public interface Setextends Collection 一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2 ，不能根据位置来获得数据元素 1 1 1 1 没有get方法，也没有根据位置插入数据的方法 public class HashSet 去重 数组（哈希表） 哈希表是一个具有算法的数组 ，如果hashset里面存储的是对象，需要重写对象的equals（）方法 12（数据%12 是数据的位置） 2 ，3 ，4 6， 9,10,34 0 1 2 3 4 5 6 7 8 9 10 11 2 3 4 6 9 10 34 两个Student的名字和年龄相同，是否为同一个Student public class TreeSet 排序 底层红黑树：平衡二叉排序树 特点：左孩子比根小，右孩子比根大 自然排序，算法和实体类绑定在一起，不易改动 比较排序 ，排序的算法和容器绑定一起 TreeSet存的数据一定要有比较算法 比较算法 ：自然排序 比较算法放在实体类里，实体类必须实现Comparable接口 比较器排序：排序算法以形参的实现传递给Treeset容器，new Comparator接口的实现类对象 上诉2选1 ，但是是自然排序的算法会固定，不好修改，建议以容器的方式，比较器的方式 如果全部实现了，比较器的优先级高：自然排序 总分排，放在一个按数学排序的TreeSet中，以数学排序为主 equals方法 set 不包含满足 e1.equals(e2) 的元素 如果将数据存在set里面： HashSet TreeSet 重写equals方法 List：存放数据，并且能够取出数据 Set：去重 HashSet 排序 TreeSet Set的改进，Set放进不能取出来，因为位置会变化，不按照位置取，给数据加个主键 hello a world b 键值对方式：存数据额时候，以key-value的方式存，map集合 map也是双列集合。他和Colletcion都属于集合，只不过Collection是单列吗，只存数据 public class HashMap&lt;K,V&gt; 线程不安全，并且 key和value可空 public class Hashtable&lt;K,V&gt; 线程安全 ，key和value非空 public class TreeMap&lt;K,V&gt; 给key排序]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类存在的问题：类里：和代码块相似静态内部类 ：static ：可以修饰代码块，修饰属性，修饰方法，修饰内部类被static 修饰的内部类实例化方式 外部类.内部类 对象名=new 外部类.内部类();静态内部类只能调用外部类的静态属性和方法外部类无法获得内部类里面的任何成员 非静态内部类没有static修饰的 实例化对象的过程：Outer.Inner nsiInner=new Outer().new Inner();非静态的内部类可以使用外部类的所有成员外部类不是使用内部类的成员如果外部类和内部的属性同名System.out.println(this.age);内部类的属性System.out.println(Outer.this.age);外部类的属性 方法里：局部内部类（几乎不用）存在方法里的内部类是局部内部类 局部内部类只能本方法中实例化对象使用，其他地方无法访问 局部内部类访问方法的局部变量，该局部变量必须要final修饰，延长生命周期 重点（匿名的东西只是为了开发编写方法） 匿名对象：没有引用的指向，只能使用一次 new 类名（）；匿名内部类：也是个对象，它是接口的实现类对象或者父类的子类对象，一般是针对接口和抽象类来使用，也是只能使用一次]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-9 Task]]></title>
    <url>%2F2018%2F08%2F09%2F8-9%20Task%2F</url>
    <content type="text"><![CDATA[1 (C)会将源文件（扩展名为java的文件）转化成类文件 （扩展名为.class的文件)A. AppletvieverB. JavaC. JavacD. 以上选项都不正确。 2 下面哪些是合法的标识符？(多选)（B,E ）A. $persons B. TwoUsers C. *point D. this E. _endline 3 （ A ） 是指在调用一个方法时，每个实际参数“值”的副本都将被传递给方法。A. 按引用传递B. 按值传递C. 按对象传递D. 以上所有选项都不正确 4 下面程序运行的结果是（ ）public class Example{ int x = 12; public void method(int x){x += x; System.out.println(x); } public static void main(String[] args){ Example t = new Example(); t.method(5); }}A.5 B.10 C.12 D.17 E.24 5 下面程序运行的结果是（B ）class Base{ private void amethod(int iBase){ System.out.println(“Base.amethod”);}}class Example extends Base{public static void main(String[] args){ Example o = new Example();int iBase = 0;o.amethod(iBase); } public void amethod(int iover){ System.out.println(“Example.amethod”); }}A.编译错误 B.运行错误 C.输出Base.amethod D.输出Example.amethod 6 下面程序运行的结果是（ D ） public class Example{class Inner{void test(){sample(); } } private Boolean flag = false;public void sample(){System.out.println(“Sample”);} public Example() { (new Inner()).test(); } public static void main(String[] args){new Example();}}A.输出Sample B.输出null C.编译错误 D.运行错误 7 下列代码运行的结果为（ A ）public class Example implements Runnable {public void run() {System.out.print(“running ”);} public static void main(String[] args){Thread t = new Thread(new Example());t.run(); t.run(); t.start();}}A.编译错误B.运行异常C.running runningD.running running running 8 下列关于泛型的说法，错误的是( B )A、泛型是一种参数化类型B、可以取代继承机制。C、避免了运行时进行类型转换可能的潜在性错误D、增强了程序的灵活性和安全性 9 以下哪些说法是正确的（ ）A. 内部类可被声明为private类。B. 外部类中数据成员可以被内部类直接访问。C. 内部类中数据成员可以被外部成员类直接访问。D. 要在内部类中访问外部类的数据成员，需要创建外部类的对象。 10 在Java中负责对字节码解释执行的是（ ）A. 垃圾回收器B. 虚拟机C. 编译器D. 多线程机制 下列哪项不是Java语言的关键字？A．gotoB．sizeofC．instanceofD．Volatile 12 Which instantiates an instance of Inner? public class Outer{ public void someOuterMethod() { // Line 3 } public class Inner{} public static void main( String[]argv ) { Outer o = new Outer(); // Line 8 } }A. new Inner(); // At line 3B. new Inner(); // At line 8C. new o.Inner(); // At line 8D. new Outer().new Inner(); // At line 8 13 下列哪个说法是错误的()。A.程序员可以定义新的异常类B.Exception 可以用 try/catch 进行捕获处理C.Exception 可以递交给上一级调用方处理D.类似像 IOException 等异常 , 程序可以忽略不进行捕获和处理 14 class Dog{ } class Harrier extends Dog { } class DogTest{ public static void main (String [] args) { Dog dl=new Dog()； Harrier hl=new Harrier()； Dog d2=hl; Harrier h2= (Harrier) d2; Harrier h3=d2; } } 下面哪一项是正确的？ A.2个Dog对象被创建 B.2个Harrier对象被创建 C.3个Harrier对象被创建 D．编译失败 15 （多选)1.interface myInterface{ int x=0; int myMethod(int x);4.}5.class myImplementation implements myInterface{ public int myMethod(int x){ return super.x;8．}9.}10.public class MyTest{ public static void Main(String[] args){ myInterface mi=new myImplementation(); System.out.println(mi.myMethod(10)); }15.}A.0B.10(在Line 7 的return super.x改成x)C. An exception is thrown at runtime.D. Compilation fails. 16 下面程序运行之后，变量x的值是（ 3）.//swap方法的声明public static void swap(int a,int b){ int t=a; a=b; b=t;}//main方法public static void main(String args[]){ int x=2; int y=3; swap(x,y);}A、2 B、3C、4 D、6 17 已知A类被打包在packageA , B类被打包在packageB ，且B类被声明为public ，且有一个成员变量x被声明为protected控制方式 。C类也位于packageA包，且继承了B类 。则以下说话正确的是（c ）A．A类的实例不能访问到B类的实例 )B．A类的实例能够访问到B类一个实例的x成员C．C类的实例可以访问到B类一个实例的x成员D．C类的实例不能访问到B类的实例 18 分析下面的Java程序：public class YY {public static void main(String[] args) throws Exception { System.out.println( method() );}private static int method(){ try{ int value = 12/0; return value;}catch(Exception e){ //System.exit(0); retrun 6;}finally{ return -1;}}}输出结果为（b ）。A．0 B．6 C．2 D．-1 19 为了使得System.out.println()输出对象引用的时候得到有意义,我们应该覆盖Object的哪个方法？( )A．equalsB．toStringC. hashCodeD．notify 20 下列关于泛型的说法不正确的一项是：（ ） A、泛型的唯一作用是提高 Java 程序的类型安全。B、泛型的可以消除源代码中的许多强制类型转换。 C、当声明或者实例化一个泛型的对象时，必须指定类型参数的值。D、实际应用中可以根据自己的需求自定义泛型 21 以下程序运行的结果是：（）public class test{static{int x=5;}static int x,y;public static void main(String args[]){ x–; myMethod( ); System.out.println(x+y+ ++x);}public static void myMethod( ){ y=x++ + ++x; }}A. 编译错误B. 输出：1C. 输出：2D. 输出：3E. 输出：7F. 输出：8 22 客户端输入一个日期，格式如下：2006-07-25 09:00:05 355 通过如下方法获得日期对象，补写下面方法完整 public static Date currentDateTime(String strDate); 23 写一个方法，将List转换成Map，比如对象Foo(code,name),List比如：A001,测试1 A002,测试2 A003,测试3 A001 ,测试4A001 ,测试5 A002,测试6比如上面的这个List,想把相同Key值的组成一个map,以上门这个为例，组成的Map有3个键值对：Key A001 Value :List A001,测试1 A001,测试4 A001,测试5Key A002 Value :List A002,测试1 A002,测试2 A002,测试6Key A003 Value :List A003,测试3另外循环List或Map时，最好是能输出能看得懂的值，你在程序里写的都是输出的对象，而不是对象的value 24 将学生对象数据：学生 编号 姓名 专业 年龄 入学日期1001 Smith 计算机 20 2010.9.11002 Peter 英语 23 2011.9.21003 Allen 物理 null 2013.9.21004 Linda 英语 23 2011.9.31005 Jerry 物理 null 2012.9.2 (1)实例化以上数据的学生对象，将数据保存到ArrayList（2）需要分别按照学生入学时间先后顺序和年龄排序。 考察点： 集合框架，排序]]></content>
      <tags>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节流和字符流]]></title>
    <url>%2F2018%2F08%2F09%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[字节流 InputStream OutputStream 一个字节读取 一个字节数组读取 FileInputStream FileOutputStream 文件字节流 ObjectInputStream ObjectOutputStream 对象序列化和反序列化 PrintStream 标准输出流 向控制台写数据,向网页写数据 BufferInputStream BufferOutputStream 高效字节流 (缓冲区) 缓冲区大小 private static int DEFAULT_BUFFER_SIZE = 8192; 8Kb 字符流 Reader Writer 一个字符char读取 一个字符数组 主要目的解决中文乱码 InputStreamReader OutputStreamWriter 字节字符流的转换流 FileReader FileWriter 文件字符流 BufferReader BufferReader 高效字符流 (缓冲区) readLine PrintWriter 标准输出流 向控制台写数据,向网页写数据 RandomAccessFile 随机输入输出流]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大事件]]></title>
    <url>%2F2018%2F08%2F08%2F8-5%20%E5%A4%A7%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[差点忘说了-&gt;有了无敌可爱的金苗苗]]></content>
      <tags>
        <tag>不忘初心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-8 Task]]></title>
    <url>%2F2018%2F08%2F08%2F8-8%20Task%2F</url>
    <content type="text"><![CDATA[第二题从一个大的文本文件中，读出此文件中的最后一行数据。并打印输出。提示：采用 RandomAccessFile 来完成。 public class Demo2 { public static void main(String[] args) throws Exception { File file = new File(&quot;E:/a.txt&quot;); // 100M long start = System.currentTimeMillis(); String lastLine = readLastLine(file, &quot;gbk&quot;); long delt = System.currentTimeMillis() - start; System.out.println(lastLine); System.out.println(&quot;读取时间(毫秒):&quot; + delt); file = new File(&quot;E:/Java练习/古诗.txt&quot;);// 仅一行文字 start = System.currentTimeMillis(); lastLine = readLastLine(file, &quot;gbk&quot;); delt = System.currentTimeMillis() - start; System.out.println(lastLine); System.out.println(&quot;读取时间(毫秒):&quot; + delt); } public static String readLastLine(File file, String charset) throws IOException { if (!file.exists() || file.isDirectory() || !file.canRead()) { return null; } RandomAccessFile raf = null; try { raf = new RandomAccessFile(file, &quot;r&quot;); long len = raf.length(); if (len == 0L) { return &quot;&quot;; } else { long pos = len - 1; while (pos &gt; 0) { pos--; raf.seek(pos); if (raf.readByte() == &apos;\n&apos;) { break; } } if (pos == 0) { raf.seek(0); } byte[] bytes = new byte[(int) (len - pos)]; raf.read(bytes); if (charset == null) { return new String(bytes); } else { return new String(bytes, charset); } } } catch (FileNotFoundException e) { } finally { if (raf != null) { try { raf.close(); } catch (Exception e2) { } } } return null; } } 第三题//使用随机文件流类RandomAccessFile将一个文本文件倒置读出。package Task8to8; import java.io.*; import java.util.*; public class Demo3 { public static final void main(String[] args) { try { File f = new File(&quot;exp.txt&quot;); if(!f.exists()) { f.createNewFile(); } RandomAccessFile raf = new RandomAccessFile(f,&quot;rw&quot;); String str = new String(); System.out.println(&quot;请输入你想要输出的字母：&quot;); str = new Scanner(System.in).next(); for(int i=0; i&lt;str.length(); i++) { raf.write(str.charAt(i)); } raf.writeUTF(str); long len = str.length(); while(0 != len--) { raf.seek(len); char ch = (char)raf.read(); System.out.print(ch+&quot; &quot;); } raf.close(); } catch(IOException e) { e.printStackTrace(); } } } 第四题编写一个程序，其功能是将两个文件的内容合并到一个文件中package Task8to8; import java.io.*; public class Demo4 { public static void main(String[] args)throws IOException { File file1=new File(&quot;e:/Java练习/古诗.txt&quot;); File file2=new File(&quot;e:/Java练习/新古诗.txt&quot;); FileInputStream fis=new FileInputStream(file2); InputStreamReader isr=new InputStreamReader(fis); FileOutputStream fos=new FileOutputStream(file1,true); OutputStreamWriter osw=new OutputStreamWriter(fos); int c; while((c=isr.read())!=-1) { osw.write((char)c); } isr.close(); osw.close(); } } 第五题利用DataInputStream类和BufferedInputStream类编写一个程序，实现从键盘读入一个字符串，在显示器上显示前两个字符的Unicode码以及后面的所有字符package Task8to8; import java.io.BufferedInputStream; import java.io.DataInputStream; import java.io.IOException; public class Demo5 { public static void main(String[] args) throws IOException { System.out.println(&quot;请输入字符串&quot;); BufferedInputStream bIS = new BufferedInputStream(new DataInputStream(System.in)); System.out.println(&quot;字符一的Unicode码：&quot; + bIS.read()); System.out.println(&quot;字符二的Unicode码：&quot; + bIS.read()); int ch = -1; while((ch = bIS.read())!=-1){ System.out.print((char) ch + &quot;\t&quot;); } System.exit(0); } }]]></content>
      <tags>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2018%2F08%2F08%2F%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) import java.util.Scanner; /* 需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) 举例： “Hello123World” 结果： 大写字符：2个 小写字符：8个 数字字符：3个* 分析： 前提：字符串要存在 A:定义三个统计变量 bigCount=0 smallCount=0 numberCount=0 B:遍历字符串，得到每一个字符。 length()和charAt()结合 C:判断该字符到底是属于那种类型的 大：bigCount++ 小：smallCount++ 数字：numberCount++* 这道题目的难点就是如何判断某个字符是大的，还是小的，还是数字的。 ASCII码表： 0 48 A 65 a 97 虽然，我们按照数字的这种比较是可以的，但是想多了，有比这还简单的 char ch = s.charAt(x);* if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’) numberCount++ if(ch&gt;=’a’ &amp;&amp; ch&lt;=’z’) smallCount++ if(ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’) bigCount++ D:输出结果。* 练习：把给定字符串的方式，改进为键盘录入字符串的方式。*/public class StringTest2 {public static void main(String[] args) {//定义一个字符串Scanner sc =new Scanner(System.in);System.out.println(“请输入一个字符串”);String name=sc.nextLine();//定义三个统计变量int bigCount = 0;int smallCount = 0;int numberCount = 0; //遍历字符串，得到每一个字符。for(int x=0; x&lt;name.length(); x++){char ch = name.charAt(x); //判断该字符到底是属于那种类型的if(ch&gt;=’a’ &amp;&amp; ch&lt;=’z’){smallCount++;}else if(ch&gt;=’A’ &amp;&amp; ch&lt;=’Z’){bigCount++;}else if(ch&gt;=’0’ &amp;&amp; ch&lt;=’9’){numberCount++;}} //输出结果。System.out.println(“大写字母”+bigCount+”个”);System.out.println(“小写字母”+smallCount+”个”);System.out.println(“数字”+numberCount+”个”);}}]]></content>
      <tags>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canlender抽象类]]></title>
    <url>%2F2018%2F08%2F08%2FCalender%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[日期 Date SimpleDateFormat Date格式化 format字符串 Canlender 抽象类 Canlender cal = new Canlender.getInstance();是他的子类对象 日期的计算 add() set() get() Canlender-&gt;Date getTime() Date-&gt;Canlender setTime(Date) 输入任何年，输出该年2月是多少天 思路： 3.1-1 get 闰年： 3.1 -1 2.29 不是闰年： 3.1-1 2.28数组：1.里面只能存放相同数据类型的数据元素2.数组定长3.数组只是一个数据类型，没有过多方法，对于多个数据元素之间操作；增删改查没有方法，需要我们手动编写对于一个容器的操作，重复的操作，Java考虑到了Java提供了这一系列的类：集合框架类 这个类一定是个抽象类或接口，绝对是集合框架的根，集合框架继承体系]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer和StringBuilder]]></title>
    <url>%2F2018%2F08%2F08%2FStringBuffer%E5%92%8CStringBuilder%2F</url>
    <content type="text"><![CDATA[StringBuffer 线程安全的可变字符序列，效率慢 jdk1.0StringBuffer()构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符。1.字符串序列拼接，拼接到尾部 append（数据） insert（int offset，插入的数据） delete（int start，int end） deleteCharAt（int index） 2.返回长度 int capacity（）返回当前容量 int length（）返回长度（字符数） 3.查找 char charAt（int index） int indexOf（String str）返回第一次出现的指定子字符串在该字符串中的索引 int lastIndexOf（String str） 4.其他 StringBuffer reverse（） 将此字符序列用其反转形式取代 replace（int start，int end。String str） 使用给定String中的字符替换此序列中的子字符串中的字符 StringBuilder 一个可变的字符序列，效率快 jdk1.5 StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 string stringbuffer stringbuilder区别： string字符串常量一旦定义内容不可变 buffer线程安全 builder线程不安全]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[###缺陷：底层是数组，需要空间连续并且数组在实例化时需要长度，那么内存空间可能长时间浪费 改进：数据不存在一起（物理分离），逻辑上是连续的##链式，链表 如果添加和删除比较频繁使用LinkedList（出库入口）数据量大的时候 如果查询比价频繁，使用Arraylist（员工系统） List是一个可以存储重复数据的集合，并且能够根据特定的位置去存储和获取数据]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型的取值范围1.byte：一个字节是八个二进制位，由于Java中有任何无符号类型，所以在八个二进制位里面有一个是符号位，7个是数值位；原码：最高位是符号位，0为正，1为负，其余位表示数值的大小； 反码：正数的反码与其原码相同，负数的反码是在其原码逐位取反，但符号位除外； 补码：正数的补码与其原码相同，负数的补码是在反码末尾加一（符号位也算计数位）； 最小数是 1 000 0000 先减一 0 111 1111 按位取反1 000 0000 = 128 byte(字节类型)一个byte 8位，取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）默认是0 short(短整型)一个short 16位，取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）默认是0 int(整型)一个int 32位，取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）默认是0 long(长整型)一个long 64位,取值范围为（-9223372036854774808~9223372036854774807）,占用8个字节（-2的63次方到2的63次方-1）默认是0L]]></content>
      <tags>
        <tag>Java知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试原因：main运行才知道有问题-&gt;每个方法自己测试：单元测试 白盒测试：代码相关，单元测试，测试单个方法 黑盒测试：用户测试（自动化） JAVA只能提供简单的功能API，不提供测试；测试厂商来完成测试方面（第三方架包，类库） 1.导入类库junit4.9 2.测试方法（必须无返回值，无参数）如果有返回值和参数，在定义一个测试方法包裹一下 File类获得文件夹中的文件public void addFile() { //创建一个文件;1.绝对路径（不建议，路径与项目无关，如果路径修改，需要变动的地方太多） File file = new File(&quot;上传文件&quot;);//在项目的路径下创建一个文件，与src目录同级 //2.相对路径：相对项目的路径 file.mkdirs(); } @Test public void deleteFile() { File file = new File(&quot;上传文件&quot;); file.delete(); } //文件夹的读取 @Test public void show() { File file = new File(&quot;src&quot;); File[] files = file.listFiles();//孩子 for(File child:files) { System.out.println(child.getName()); } } @Test public void showAll(String fileName) { File file = new File(fileName); System.out.println(file.getName()); File[] files = file.listFiles();//孩子 //出口 if(files.length==0) { //空 return; } for(File child:files) { //判断孩子是文件还是文件夹 if(child.isFile()) { //文件 System.out.println(child.getName()); }else { //文件夹，以相同的方式遍历，不断地缩短问题 showAll(child.getAbsolutePath()); } } } @Test public void testshowAll() { showAll(&quot;MacOS:\\Users\\gf&quot;); } public void remove(String name) { File file = new File(name); File[] files = file.listFiles(); if(files.length==0) { file.delete(); }else { //不为空，先删除孩子 for(File child:files) { if(child.isFile()) { child.delete(); }else { //如果孩子是文件夹以相同的方式处理 remove(child.getAbsolutePath()); } } } if(file.exists()){ file.delete();//如果还存在，删除自己 } } file 删除 如果是文件,直接删除,如果是文件夹,必须先将内容删除,然后才能删除空文件夹 在java里面设备与设备之间的信息传输都是以流的形式 小说：发给你视频：发给你 单位：计算机以什么单位存储 字节 8bit 8个01组成 小说，一个个字节发给你：网络 1m=1024kb 1kb=1024b 中文乱码：####设备与设备之间的传输问题 中文不是一个字节，是多个字节 ##编码方式： ASCII:一个字节，存储字母，表达的东西比较少 Unicode：2个字节 前一个字节是ASCII,后面是补充（中文）2个字节存储还是有限 utf-8：三个字节，存储中文，一个中文三个字节 GBK：表示中文，一个中文两个字节 明白java如何操作流 public abstract class InputStream extends Objectimplements Closeable此抽象类是表示字节输入流的所有类的超类。 需要定义 InputStream 子类的应用程序必须总是提供返回下一个输入字节的方法。 public abstract class OutputStream extends Objectimplements Closeable, Flushable此抽象类是表示输出字节流的所有类的超类。输出流接受输出字节并将这些字节发送到某个接收器。 需要定义 OutputStream 子类的应用程序必须始终提供至少一种可写入一个输出字节的方法。 public class FileOutputStreamextends OutputStream 文件输出流 public class FileInputStreamextends InputStream int read() 从此输入流中读取一个数据字节。 int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 中文乱码: 设备和设备之间的传输,都会遇到的问题 中文不是一个字节,是多个字节 编码方式: ASCII:1个字节,存储字母,表达的东西比较少 Unicode: 2个字节 前一个字节是ASCII,后面是补充(中文) 2个字节存储还是有限 utf-8:3个字节,存储中文,如果是UTF-8的形式,一个中文3个字节 GBK :表示中文 ,一个中文2个字节 中文常用的字符UTF-8 和GBK ,更倾向于前者 IO中文乱码处理 ,以字节问单位,字节流输入字节流和输出字节流字符流 以char来传输 输入字符流和输出字符流什么时候用字节流,什么时候用字符流? 文本有中文用字符流,其他都用字节流,因为字节是基本单位字符: Reader输入字符流 Writer 输出字符流 public abstract class Reader extends Objectimplements Readable, Closeable用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 public abstract class Writer extends Objectimplements Appendable, Closeable, Flushable写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。但是，多数子类将重写此处定义的一些方法，以提供更高的效率和/或其他功能。 不管是字符还是字节,计算机的底层还是字节传输 public class InputStream Readerextends ReaderInputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。 将字节转成字符]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UUU]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%85%AB%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E6%AF%94byte%20short%20int%20long%20char%20double%20float%20Boolean%2F</url>
    <content type="text"><![CDATA[八个基本数据类型 比byte short int long char double float Boolean基本数据类型-&gt;包装类]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2018%2F08%2F08%2FMarkdown%2F</url>
    <content type="text"><![CDATA[MacDownHello there! I’m MacDown, the open source Markdown editor for OS X. Let me introduce myself. Markdown and IMarkdown is a plain text formatting syntax created by John Gruber, aiming to provide a easy-to-read and feasible markup. The original Markdown syntax specification can be found here. MacDown is created as a simple-to-use editor for Markdown documents. I render your Markdown contents real-time into HTML, and display them in a preview panel. I support all the original Markdown syntaxes. But I can do so much more! Various popular but non-standard syntaxes can be turned on/off from the Markdown preference pane. You can specify extra HTML rendering options through the Rendering preference pane. You can customize the editor window to you liking in the Editor preferences pane: You can configure various application (that’s me!) behaviors in the General preference pane. The BasicsBefore I tell you about all the extra syntaxes and capabilities I have, I’ll introduce you to the basics of standard markdown. If you already know markdown, and want to jump straight to learning about the fancier things I can do, I suggest you skip to the Markdown preference pane. Lets jump right in. Line BreaksTo force a line break, put two spaces and a newline (return) at the end of the line. This two-line bulletwon’t break This two-line bulletwill break Here is the code: 12345* This two-line bullet won&apos;t break* This two-line bullet will break Strong and EmphasizeStrong: **Strong** or __Strong__ (Command-B)Emphasize: *Emphasize* or _Emphasize_[^emphasize] (Command-I) Headers (like this one!)Header 1 ======== Header 2 -------- or # Header 1 ## Header 2 ### Header 3 #### Header 4 ##### Header 5 ###### Header 6 Links and EmailInlineJust put angle brackets around an email and it becomes clickable: &#x75;&#114;&#x61;&#x6e;&#x75;&#x73;&#x6a;&#114;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;&lt;uranusjr@gmail.com&gt; Same thing with urls: http://macdown.uranusjr.com&lt;http://macdown.uranusjr.com&gt; Perhaps you want to some link text like this: Macdown Website[Macdown Website](http://macdown.uranusjr.com &quot;Title&quot;) (The title is optional) Reference styleSometimes it looks too messy to include big long urls inline, or you want to keep all your urls together. Make a link [a link][arbitrary_id] then on it’s own line anywhere else in the file:[arbitrary_id]: http://macdown.uranusjr.com &quot;Title&quot; If the link text itself would make a good id, you can link like this [like this][], then on it’s own line anywhere else in the file:[like this]: http://macdown.uranusjr.com ImagesInline![Alt Image Text](path/or/url/to.jpg &quot;Optional Title&quot;) Reference style![Alt Image Text][image-id]on it’s own line elsewhere:[image-id]: path/or/url/to.jpg &quot;Optional Title&quot; Lists Lists must be preceded by a blank line (or block element) Unordered lists start each item with a * - works too Indent a level to make a nested list Ordered lists are supported. Start each item (number-period-space) like 1. It doesn’t matter what number you use, I will render them sequentially So you might want to start each line with 1. and let me sort it out Here is the code: 12345678* Lists must be preceded by a blank line (or block element)* Unordered lists start each item with a `*`- `-` works too * Indent a level to make a nested list 1. Ordered lists are supported. 2. Start each item (number-period-space) like `1. ` 42. It doesn&apos;t matter what number you use, I will render them sequentially 1. So you might want to start each line with `1.` and let me sort it out Block Quote Angle brackets &gt; are used for block quotes.Technically not every line needs to start with a &gt; as long asthere are no empty lines between paragraphs.Looks kinda ugly though. Block quotes can be nested. Multiple Levels Most markdown syntaxes work inside block quotes. Lists Links Etc. Here is the code: 123456789101112&gt; Angle brackets `&gt;` are used for block quotes. Technically not every line needs to start with a `&gt;` as long asthere are no empty lines between paragraphs. &gt; Looks kinda ugly though.&gt; &gt; Block quotes can be nested. &gt; &gt; &gt; Multiple Levels&gt;&gt; Most markdown syntaxes work inside block quotes.&gt;&gt; * Lists&gt; * [Links][arbitrary_id]&gt; * Etc. Inline CodeInline code is indicated by surrounding it with backticks:`Inline code` If your code has `backticks` that need to be displayed, you can use double backticks:``Code with `backticks` `` ```` (mind the spaces preceding the final set of backticks)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950### Block CodeIf you indent at least four spaces or one tab, I&apos;ll display a code block. print(&apos;This is a code block&apos;) print(&apos;The block must be preceded by a blank line&apos;) print(&apos;Then indent at least 4 spaces or 1 tab&apos;) print(&apos;Nesting does nothing. Your code is displayed Literally&apos;)I also know how to do something called [Fenced Code Blocks](#fenced-code-block) which I will tell you about later.### Horizontal RulesIf you type three asterisks `***` or three dashes `---` on a line, I&apos;ll display a horizontal rule:***## &lt;a name=&quot;markdown-pane&quot;&gt;&lt;/a&gt;The Markdown Preference PaneThis is where I keep all preferences related to how I parse markdown into html. ![Markdown preferences pane](http://d.pr/i/RQEi+)### Document FormattingThe ***Smartypants*** extension automatically transforms straight quotes (`&quot;` and `&apos;`) in your text into typographer’s quotes (`“`, `”`, `‘`, and `’`) according to the context. Very useful if you’re a typography freak like I am. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence.### Block Formatting#### TableThis is a table:First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content CellYou can align cell contents with syntax like this:| Left Aligned | Center Aligned | Right Aligned ||:------------- |:---------------:| -------------:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |The left- and right-most pipes (`|`) are only aesthetic, and can be omitted. The spaces don’t matter, either. Alignment depends solely on `:` marks.#### &lt;a name=&quot;fenced-code-block&quot;&gt;Fenced Code Block&lt;/a&gt;This is a fenced code block: print(‘Hello world!’)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071You can also use waves (`~`) instead of back ticks (`` ` ``):~~~print(&apos;Hello world!&apos;)~~~You can add an optional language ID at the end of the first line. The language ID will only be used to highlight the code inside if you tick the ***Enable highlighting in code blocks*** option. This is what happens if you enable it:![Syntax highlighting example](http://d.pr/i/9HM6+)I support many popular languages as well as some generic syntax descriptions that can be used if your language of choice is not supported. See [relevant sections on the official site](http://macdown.uranusjr.com/features/) for a full list of supported syntaxes.### Inline FormattingThe following is a list of optional inline markups supported:Option name | Markup | Result if enabled |--------------------|------------------|-----------------------|Intra-word emphasis | So A\*maz\*ing | So A&lt;em&gt;maz&lt;/em&gt;ing |Strikethrough | \~~Much wow\~~ | &lt;del&gt;Much wow&lt;/del&gt; |Underline [^under] | \_So doge\_ | &lt;u&gt;So doge&lt;/u&gt; |Quote [^quote] | \&quot;Such editor\&quot; | &lt;q&gt;Such editor&lt;/q&gt; |Highlight | \==So good\== | &lt;mark&gt;So good&lt;/mark&gt; |Superscript | hoge\^(fuga) | hoge&lt;sup&gt;fuga&lt;/sup&gt; |Autolink | http://t.co | &lt;http://t.co&gt; |Footnotes | [\^4] and [\^4]: | [^4] and footnote 4 |[^4]: You don&apos;t have to use a number. Arbitrary things like `[^footy note4]` and `[^footy note4]:` will also work. But they will *render* as numbered footnotes. Also, no need to keep your footnotes in order, I will sort out the order for you so they appear in the same order they were referenced in the text body. You can even keep some footnotes near where you referenced them, and collect others at the bottom of the file in the traditional place for footnotes. ## &lt;a name=&quot;rendering-pane&quot;&gt;&lt;/a&gt;The Rendering Preference PaneThis is where I keep preferences relating to how I render and style the parsed markdown in the preview window. ![Rendering preferences pane](http://d.pr/i/rT4d+)### CSSYou can choose different css files for me to use to render your html. You can even customize or add your own custom css files.### Syntax HighlightingYou have already seen how I can syntax highlight your fenced code blocks. See the [Fenced Code Block](#fenced-code-block) section if you haven’t! You can also choose different themes for syntax highlighting.### TeX-like Math SyntaxI can also render TeX-like math syntaxes, if you allow me to.[^math] I can do inline math like this: \\( 1 + 1 \\) or this (in MathML): &lt;math&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;, and block math:\\[ A^T_S = B\\]or (in MathML)&lt;math display=&quot;block&quot;&gt; &lt;msubsup&gt;&lt;mi&gt;A&lt;/mi&gt; &lt;mi&gt;S&lt;/mi&gt; &lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mi&gt;B&lt;/mi&gt;&lt;/math&gt;### Task List Syntax1. [x] I can render checkbox list syntax * [x] I support nesting * [x] I support ordered *and* unordered lists2. [ ] I don&apos;t support clicking checkboxes directly in the html window### Jekyll front-matterIf you like, I can display Jekyll front-matter in a nice table. Just make sure you put the front-matter at the very beginning of the file, and fence it with `---`. For example: title: “Macdown is my friend” date: 2014-06-06 20:00:00` Render newline literallyNormally I require you to put two spaces and a newline (aka return) at the end of a line in order to create a line break. If you like, I can render a newline any time you end a line with a newline. However, if you enable this, markdown that looks lovely when I render it might look pretty funky when you let some other program render it. The General Preferences PaneThis is where I keep preferences related to application behavior. The General Preferences Pane allows you to tell me how you want me to behave. For example, do you want me to make sure there is a document open when I launch? You can also tell me if I should constantly update the preview window as you type, or wait for you to hit command-R instead. Maybe you prefer your editor window on the right? Or to see the word-count as you type. This is also the place to tell me if you are interested in pre-releases of me, or just want to stick to better-tested official releases. The Editor Preference PaneThis is where I keep preferences related to the behavior and styling of the editing window. StylingMy editor provides syntax highlighting. You can edit the base font and the coloring/sizing theme. I provided some default themes (courtesy of Mou’s creator, Chen Luo) if you don’t know where to start. You can also edit, or even add new themes if you want to! Just click the Reveal button, and start moving things around. Remember to use the correct file extension (.styles), though. I’m picky about that. I offer auto-completion and other functions to ease your editing experience. If you don’t like it, however, you can turn them off. Hack OnThat’s about it. Thanks for listening. I’ll be quiet from now on (unless there’s an update about the app—I’ll remind you for that!). Happy writing! [^emphasize]: If Underlines is turned on, _this notation_ will render as underlined instead of emphasized [^under]: If Underline is disabled _this_ will be rendered as emphasized instead of being underlined. [^quote]: Quote replaces literal &quot; characters with html &lt;q&gt; tags. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence. Note that Quote is different from blockquote, which is part of standard Markdown. [^math]: Internet connection required.]]></content>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java日期时间]]></title>
    <url>%2F2018%2F08%2F08%2FJava%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Java日期时间java.util提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象 Date(); //使用当前的日期和时间来初始化对象 Date(long millisec); //接受一个参数，该参数是从1970年1月1日起的毫秒数。 Date对象创建后可以调用如下方法： boolean after(Date date) 调用此方法的Date对象在指定日期之后返回true，否则false boolean before(Date date)调用此方法的Date对象在指定日期之前返回false，否则true Object clone() 返回此对象的副本 int compareTo(Date date) 比较调用此方法的Date对象和指定日期相等返回零。调用对象在指定日期之前返回负数，在指定日期之后返回正数 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date date),否则抛出ClassCastException boolean equals(Object date)当调用此方法的Date对象和指定日期相等返回true，否则返回false long getTime() 返回自1970年开始此Date对象表示的毫秒数 int hashCode()返回此对象的哈希值 void setTime(long time) 用自1970开始的毫秒数设置日期和时间 String toString()把此Date对象转换成以下形式的string：dow mon dd hh:mm:ss zzz yyyy 其中：dow是一周中的某一天（sun，mon，tue，wed，thu，fri，sat） 获取当前日期和时间java中获取当前日期和时间，使用Date对象的toString()方法来打印当前日期和时间12345678import java.util.Date;public class DateDemo&#123; public static void main(String args[])&#123; Date date = new Date(); //使用toString()函数显示日期时间 System.out.println(date.toString()); &#125;&#125; 日期比较java使用以下三种方法来比较两个日期： 使用getTime()方法来获取两个日期，比较这两个值； 使用方法before（），after（），equals（）。 使用compareTo（）方法，它是由Comparable接口定义的，Date类实现了这个接口 使用SimpleDateFormat格式化日期SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期时间格式来运行。123456789import java.util.*;import java.text.*;public class DateDemo&#123; public static void main(String[] args)&#123; Date dNow = new Date(); SimpleDateFormat ft = new SimpleDateFormat(&quot;E yyyt.MM.dd &apos;at&apos; hh:mm:ss a zzz&quot;); System.out.println(&quot;Current Date:&quot;+ft.format(dNow)); &#125;&#125; 日期和时间的格式化编码 时间模式字符串用来指定时间格式。在此模式中，所有的ASCII字母被保留为模式字母，定义如下： 使用print格式化日期]]></content>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>README</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-7-Task]]></title>
    <url>%2F2018%2F08%2F08%2F8-7%20Task%2F</url>
    <content type="text"><![CDATA[1.编写异常类：空异常、年龄低异常、年龄高异常、 工资低异常、工资高异常、身份证非法异常。2.编写一个员工类，(1) 有属性： 编号，姓名，年龄，工资，身份证号码，员工人数，员工工资总额 (2) 有构造器： 构造器1：设置编号，年龄，姓名；如果年龄小于18，抛出年龄低异常；如果年龄大于60抛出年龄高异常，如果姓名为null或为空字符串，抛出空异常。 构造器2：设置工资，设置身份证号码；如果工资低于600，抛出工资低异常。 (3) 有方法 增加工资 addSalary(double addSalary)，抛出工资高异常，当增加后的工资大于员工工资总额时，抛出此异常。 减少工资 minusSalary(double minusSalary), 抛出工资低异常，当减少后的工资低于政府最低工资时，抛出工资低异常。 显示员工工资总额方法：showTotalSalary(), 抛出空异常，当工资总额为0时，抛出此异常。 显示员工人数：void showTotalEmployee（），抛出空异常。当员工人数为0时，抛出此异常。 2 编写一个程序实现以下功能：（1）产生5000个1～9999之间的随机整数，将其存入文本文件a.txt中。123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.util.ArrayList;import java.util.List;import java.util.Random;public class Test &#123;public static void main(String[] args) &#123;List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(5000);Random random = new Random();for (int i = 0; i &lt; 5000; i++) &#123;Integer r = null;do// 由于要求1～9999，所以得排除0的情况r = random.nextInt(10000);while (r == 0);arr.add(random.nextInt(10000));&#125;try &#123;BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;C:\\a.txt&quot;)));for (Integer i : arr) &#123;bw.write(String.valueOf(i));bw.newLine();&#125;bw.close();&#125; catch (FileNotFoundException e) &#123;e.printStackTrace();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;&#125;``` （2）从文件中读取这5000个整数，并计算其最大值、最小值和平均值并输出结果。 import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.util.Random; public class Demo17 { public static void main(String[] args) throws Exception { /* * 编写一个程序实现以下功能：()考虑内存优化 ①产生5000个1～9999之间的随机整数，将其存入文本文件a.txt中。 ②从文件中读取这5000个整数，并计算其最大值、最小值和平均值并输出结果。 */ Random r = new Random(); File file = new File(&quot;G:/a/b/c/a.txt&quot;); FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw); for (int i = 0; i &lt; 5000; i++) { bw.write((r.nextInt(9999)+1)+&quot;&quot;); bw.newLine(); bw.flush(); fw.flush(); } bw.close(); fw.close(); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); String s=&quot;&quot;; int index=0; int a[] = new int [5000]; while((s=br.readLine())!=null) { System.out.println(s); a[index] = Integer.valueOf(s); index++; } System.out.println(&quot;最大值：&quot;+GetMax(a)); br.close(); fr.close(); } public static int GetMax(int [] a) { int max = a[0]; for (int i = 1; i &lt; a.length; i++) { if(a[i]&gt;max) { max =a[i]; } } return max; } }1#### 3 在电脑D盘下创建一个文件为HelloWorld.txt文件，判断他是文件还是目录，在创建一个目录IOTest,之后将HelloWorld.txt移动到IOTest目录下去；之后遍历IOTest这个目录下的文件 import java.io.File;import java.io.IOException; public class Test1 { /** * 1. 在电脑D盘下创建一个文件为HelloWorld.txt文件， * 判断他是文件还是目录，再创建一个目录IOTest, * 之后将HelloWorld.txt移动到IOTest目录下去； * 之后遍历IOTest这个目录下的文件 * * 程序分析： * 1、文件创建使用File的createNewFile()方法 * 2、判断是文件用isFile(),判断是目录用isDirectory * 3、创建目录用：mkdirs()方法 * 4、移动文件用：renameTo * 5、遍历目录用：list（）方法获得存放文件的数组，foreach遍历的方法把文件打印出来 * */ public static void main(String[] args) { //在电脑D盘下创建一个文件为HelloWorld.txt文件 File file=new File(&quot;D:&quot;,&quot;HelloWorld.txt&quot;); //创建文件，返回一个布尔值 boolean isCreate; try { isCreate = file.createNewFile(); if (isCreate) { System.out.println(&quot;创建文件成功！&quot;); }else { System.out.println(&quot;创建文件失败！文件已经存在&quot;); } } catch (IOException e) { System.out.println(&quot;创建文件失败！&quot;); } // 判断他是文件还是目录， if (file.isFile()) { System.out.println(&quot;这是一个文件&quot;); } else { System.out.println(&quot;这是一个目录&quot;); } //再创建一个目录IOTest File file2=new File(&quot;D:/IOTest&quot;); file2.mkdirs(); //HelloWorld.txt移动到IOTest目录下去?失败？》 if (file.renameTo(file2)) { System.out.println(&quot;文件移动成功！&quot;); } else { System.out.println(&quot;文件移动失败&quot;); } //遍历IOTest目录下的文件 String[] arr=file2.list(); for (String string : arr) { System.out.println(string); } } } 1 #### 4 递归实现输入任意目录，列出文件以及文件夹 import java.io.File;import java.io.IOException;public class Test1 { /** * 1. 在电脑D盘下创建一个文件为HelloWorld.txt文件， * 判断他是文件还是目录，再创建一个目录IOTest, * 之后将HelloWorld.txt移动到IOTest目录下去； * 之后遍历IOTest这个目录下的文件 * * 程序分析： * 1、文件创建使用File的createNewFile()方法 * 2、判断是文件用isFile(),判断是目录用isDirectory * 3、创建目录用：mkdirs()方法 * 4、移动文件用：renameTo * 5、遍历目录用：list（）方法获得存放文件的数组，foreach遍历的方法把文件打印出来 * */ public static void main(String[] args) { //在电脑D盘下创建一个文件为HelloWorld.txt文件 File file=new File(&quot;D:&quot;,&quot;HelloWorld.txt&quot;); //创建文件，返回一个布尔值 boolean isCreate; try { isCreate = file.createNewFile(); if (isCreate) { System.out.println(&quot;创建文件成功！&quot;); }else { System.out.println(&quot;创建文件失败！文件已经存在&quot;); } } catch (IOException e) { System.out.println(&quot;创建文件失败！&quot;); } // 判断他是文件还是目录， if (file.isFile()) { System.out.println(&quot;这是一个文件&quot;); } else { System.out.println(&quot;这是一个目录&quot;); } //再创建一个目录IOTest File file2=new File(&quot;D:/IOTest&quot;); file2.mkdirs(); //HelloWorld.txt移动到IOTest目录下去?失败？》 if (file.renameTo(file2)) { System.out.println(&quot;文件移动成功！&quot;); } else { System.out.println(&quot;文件移动失败&quot;); } //遍历IOTest目录下的文件 String[] arr=file2.list(); for (String string : arr) { System.out.println(string); } } }主方法调用类 import java.io.File;import java.util.List; public class Test2 { /** * 递归实现输入任意目录，列出文件以及文件夹 * * 设计：在FileUtils类里面实现了逻辑操作，在另一边调用就可以了 * */ public static void main(String[] args) { //比如输入D盘 Listlist=FileUtils.getAllFiles(&quot;D:&quot;); //输出所有的文件和文件夹的名字 for (File file : list) { System.out.println(file); } } } ` 5 建立exception包，建立Bank类，类中有变量double balance表示存款,Bank类的构造方法能增加存款，Bank类中有取款的发方法withDrawal(double dAmount),当取款的数额大于存款时,抛出InsufficientFundsException,取款数额为负数，抛出NagativeFundsException,如new Bank(100),表示存入银行100元，当用方法withdrawal(150)，withdrawal(-15)时会抛出自定义异常。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//Bank类package d0923;public class Bank &#123;private double balance;Bank(double a) &#123;balance += a;&#125;void withDrawal(double dAmount) throws InsufficientFundsException, NagativeFundsException &#123;if(dAmount&lt;0)throw new InsufficientFundsException(dAmount);if(dAmount&gt;balance)throw new NagativeFundsException();System.out.println(&quot;取款：&quot;+dAmount);this.balance-=dAmount;&#125;&#125;///InsufficientFundsExceptionpackage d0923;public class InsufficientFundsException extends Exception &#123;InsufficientFundsException(double i)&#123;System.out.println(&quot;发生错误：&quot;+&quot;取款额&quot;+i+&quot;为负数。&quot;);&#125;&#125;///NagativeFundsExceptionpackage d0923;public class NagativeFundsException extends Exception &#123;NagativeFundsException()&#123;System.out.println(&quot;超出余额：&quot;);&#125;&#125;package d0923;public class NagativeFundsException extends Exception &#123;NagativeFundsException()&#123;System.out.println(&quot;超出余额：&quot;);&#125;&#125;//测试主类package d0923;public class TestBank &#123;public static void main(String[] args) &#123;Bank b=new Bank(100);try&#123;b.withDrawal(-15);&#125;catch(InsufficientFundsException e)&#123;e.printStackTrace();&#125;catch(NagativeFundsException e)&#123;e.printStackTrace();&#125;try&#123;b.withDrawal(150);&#125;catch(InsufficientFundsException | NagativeFundsException e)&#123;e.printStackTrace();&#125;&#125;&#125;//运行结果发生错误：取款额-15.0为负数。 ///withdrawal调用的构造函数d0923.InsufficientFundsExceptionat d0923.Bank.withDrawal(Bank.java:12) /// printStackat d0923.TestBank.main(TestBank.java:8)超出余额：d0923.NagativeFundsExceptionat d0923.Bank.withDrawal(Bank.java:14)at d0923.TestBank.main(TestBank.java:20)]]></content>
      <tags>
        <tag>Task</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day05]]></title>
    <url>%2F2018%2F07%2F31%2FDay05%2F</url>
    <content type="text"><![CDATA[OPP和OOP的区别：OPP过程开发：程序和程序运行过程一致，从上而下分析业务编写代码OOP面向对象开发：提取能够完成业务功能的对象，然后相互合作 类和对象区别：类是抽象的模板；对象是类的实体 ####数组的特点： 1. 只能存储同一种数据类型的数据。 2. 一旦初始化，长度固定。 3. 数组中的元素与元素之间的内存地址是连续的。 setter和getter方法的作用：封装数据，对私有属性进行封装，只是暴露出public方法来访问。但是为什么要这么做，原因很简单，封装的作用就是保护，保护属性本身不被篡改。 比如有些属性只是可读但不可写，那么只提供它的getter方法就好，意思就是某些属性只能单一方向的被访问， getter和setter就是提供这样的接口，对于public的属性，可以直接使用类名来访问，自身的“安全性”就降低了。 toString方法的作用：返回该对象的字符串表示。通常， toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 简述对象实例化的过程： 1、 如果存在继承关系，就先父类后子类； 2 、如果在类内有静态变量和静态块，就先静态后非静态，最后才是构造函数； 3 、继承关系中，必须要父类初始化完成后，才初始化子类。 函数的重载：多个函数的名字相同，但是形参列表不同(参数类型不同或参数个数不同)，返回值类型可同也可不同，我们称之为重载函数。重载的函数是通过形参列表区分的，与返回值类型无关。 不定参数的格式： 第一，方法的参数列表中最多只有一个不定长度的参数； 第二，就是不定长度的数组的位置必须是最后一个参数。不然不能通过编译。 参数的类型相同，只是参数的个数不定 构造方法的要求及作用：没有返回值，方法和类同名；没有jvm会默认添加无参的构造创建和初始化对象；]]></content>
      <tags>
        <tag>Day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承;2C]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%BB%A7%E6%89%BF-2C%2F</url>
    <content type="text"><![CDATA[继承继承的特性 子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类， 多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类， 这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 implements关键字使用 implements 关键字可以变相的使java具有多继承的特性， 使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写 构造器 子类不能继承父类的构造器（构造方法或者构造函数） 如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。]]></content>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaAPI]]></title>
    <url>%2F2018%2F07%2F31%2FJavaAPI%2F</url>
    <content type="text"><![CDATA[JavaAPIjava默认的包是Java.lang = language Java语言包，该包下的所有类使用无需导入包，否则需要！ Object类是层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。 子类都可以重写父类的方法，意味着任何类都可以继承或重写object的所有方法除非（final，private） 1Object（）无参构造，即默认的构造方法 数组里只能存放相同的数据元素-&gt;解决办法：1Object[] arrs = &#123;1,2.0,&quot;你好&quot;,new Date(),false&#125;; 原理：多态，子父类方法摘要protected Object clone() 12345 boolean equals(Object obj) **equals（）是一个方法只有对象才可以调用** ```指示其他某个对象是否与此对象“相等”。 String toString() 默认可以省去，一般子类会重写toString方法来输出属性值 变量拼接，先开辟空间，再拼接 1234567 **字符串在字符串常量池里， String缺陷在做字符串拼接的时候，反复的开辟和销毁空间** #### 1.protected void finalize() ```当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃 圾回收器调用此方法。 2.Class&lt;?&gt; getClass() Object 的运行时类。```1234 #### 3.int hashCode() ``` 返回该对象的哈希码值。 4.void notify() 1234 #### 5.void notifyAll() ``` 唤醒在此对象监视器上等待的所有线程。 6.void wait() notify() 方法或 notifyAll() 方法前，导致当前线程等待。```1234 #### 7.void wait(long timeout) ```在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。 8.void wait(long timeout, int nanos) 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。]]></content>
      <tags>
        <tag>JavaAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的方法]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串的方法1.基本数据类型转成字符串的方法valueOf()static String valueOf(boolean b) boolean 参数的字符串表示形式。```123 static String valueOf(char c) ``` 返回 char 参数的字符串表示形式。 static String valueOf(char[] data) char 数组参数的字符串表示形式。```123 static String valueOf(char[] data, int offset, int count) ```返回 char 数组参数的特定子数组的字符串表示形式。 static String valueOf(double d) double 参数的字符串表示形式。```123 static String valueOf(float f) ``` 返回 float 参数的字符串表示形式。 static String valueOf(int i) int 参数的字符串表示形式。```123 static String valueOf(long l) ``` 返回 long 参数的字符串表示形式。 static String valueOf(Object obj) Object 参数的字符串表示形式。```1234 ### 2.截取方法 String substring(int beginIndex) ``` 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 12 **代码：** public String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。示例： “hamburger”.substring(4, 8) returns “urge” “smiles”.substring(1, 5) returns “mile” 12345678910111213141516171819202122232425262728293031323334353637参数：beginIndex - 起始索引（包括）endIndex - 结束索引（不包括）。返回：指定的子字符串。抛出：IndexOutOfBoundsException - 如果 beginIndex 为负，或 endIndex 大于此 String 对象的长度，或 beginIndex 大于 endIndex。 ### 3.查找#### indexOf 第一次出现的位置#### lastIndexOf 最后一次出现的位置#### boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 #### boolean contains(CharSequence s) 当且仅当此字符串包含指定的 char 值序列时，返回 true。 #### int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。#### char charAt(int index) 返回指定索引处的 char 值。 * int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 * int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 * int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 String str = “”; int count = 0; while(str.length()&gt;0){ int index = str.indexOf(“java”); if(index&gt;=0){ count++; str = str.substring(index+4); }else{ break } } System.out.println(count+”次”); 1234567891011121314151617181920## 4.大小写的问题（）* 1.boolean equals(Object anObject) 将此字符串与指定的对象比较。* 2.boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。* 3.String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。* 4.String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。###问题：输入字符串，把一个字符串的首字符转为大写**代码：** public class UpperAndLower{ public static void main(String[] args){ Scanner scanner = new Scanner(System.in); System.out.println(“请输入字符串：”); String string = scanner.next().trim();//去掉前面所有和后面所有的空格 String newString = string.substring(0,1).toupperCase()+string.substring(1).toLowerCase(); System.out.println(“newString”); }}` 5.其他 String trim(): 返回字符串的副本，忽略前导空白和尾部空白。 String[] split(String regex) :根据给定正则表达式的匹配拆分此字符串。 int compareTo(String anotherString) :按字典顺序比较两个字符串。 int compareToIgnoreCase(String str) : 按字典顺序比较两个字符串，不考虑大小写。 String replace(char oldChar, char newChar) :返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。]]></content>
      <tags>
        <tag>字符串的方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念一]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%A6%82%E5%BF%B5%E4%B8%80%2F</url>
    <content type="text"><![CDATA[面向对象：1.什么是oopOOP：Object Oriented Programming;面向对象的程序设计。所谓“对象“在显示支持面向对象的语言中，一般是指类在内存中装载的实例，具有相关的成员变量和成员函数（方法）。面对对象的程序设计完全不同于传统的面向过程程序设计，它大大降低了软件开发的难度。 OOP达到了软件工程的三个主要目标：重用性，灵活性和拓展性； 2.重写和重载的区别重写：子类定义的方法与父类中的方法具有相同的方法名字，相同的参数表和返回类型： 子类中不能重写父类中的final方法 子类中必须重写父类的abstract方法重载：同一个类中的多个方法具有相同的名字，但这些名字具有不同的参数列表，即参数的数量和参数类型不能完全相同 3.接口和实现类的区别接口（interface）在Java语言中就是一个抽象类型，但接口不是抽象类，是抽象方法的集合。类通过继承接口的方式来继承接口的抽象方法。 接口无法被实例化，但是可以被实现；一个实现接口的类必须实现接口内描述的所有方法，否则必须声明为抽象类。 4.简述staticstatic方法就是没有this的方法，在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来条用static方法。这实际上就是static方法的主要用途。 方便在没有创建对象的时候调用（方法/变量） 5.简述final关键字可以修饰类，方法和变量（包括成员变量和局部变量） 6.一个实体类实例化的对象的过程1.递归的在堆中首先创建其父类对象，调用父类构造方法。 2.创建对象自己，执行构造方法实例化。 3.Java中类的构造方法默认第一行都是super（），即调用父类构造方法。 4.在对象的实例化过程中，若类中有代码块或静态代码块，代码块是先于构造方法执行的 7.什么是多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是一个接口，使用不同的实例执行不同的操作。 优点： 1.消除类型之间的耦合关系 2.可替换性 3.可扩充性 4.接口性 5.灵活性 6.简化性 存在条件 继承 重写 父类引用指向子类对象 8.向上转型和向下转型需要注意哪些向上转型：子类引用的对象转换成父类类型 减少重复代码，使代码简洁 提高系统扩展性 向下转型：父类对象转为子类对象注意事项 前提是父类对象指向的是子类对象（也就是要先向上转型） 只能转型为本类对象 9.面向对象的特征有哪些 抽象 封装 多态 继承 10.说说你熟悉的设计模式 单例 工厂 模板 11.this和super的区别首先不可同时出现；都位于第一行 this用于同一个类中从某个构造函数调用另一个重载版的构造函数 super用于在子类构造函数中调用父类的构造函数 12.匿名内部类如何使用匿名内部类定义假如一个局部内部类只被用一次（只用它构建一个对象），就可以不用对其命名了，这种没有名字的类被称为匿名内部类（anonymous inner class），其代码格式通常为：123new SuperType(construction parameters)&#123; inner class methods and data&#125;; 匿名内部类的构造器 由于构造器的名字必须与类名相同，而匿名内部类没有类名，所以匿名类不能含有构造器。取而代之的是将构造器参数传递给超类（superclass）的构造器。 当匿名类实现某个接口的时候，一定不能存在任何构造参数。这时，代码格式构成变成如下所示：123new InterfaceType()&#123; methods and data&#125;;]]></content>
      <tags>
        <tag>面试概念总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式与工厂模式与模板模式]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例：最多一个实例对象工厂模式：所有对象都由工厂生产（静态工厂）模板模式：父类定义好了算法步骤，对于每个步骤的具体实现由子类来实现，通过多态的方式，根据具体子类来完成具体的算法步骤。例子：做菜（提取模板来约束）： 配备食材（不同的菜食材不一样） 切菜 烧菜 //模板设计模式 public abstract class Cook { //设计模板 public abstract void ready(); //1 public abstract void wash(); //2 public abstract void cook(); //3 //统一规范 public final void cookFull() { //固定模板，禁止子类修改 ready(); wash(); cook(); } } 番茄鸡蛋 public class TomatoAndEgg extends Cook { @Override public void ready() { // TODO Auto-generated method stub System.out.println(&quot;准备番茄鸡蛋&quot;); } // @Override public void wash() { // TODO Auto-generated method stub System.out.println(&quot;洗番茄鸡蛋&quot;); // } // @Override public void cook() { // TODO Auto-generated method stub System.out.println(&quot;做番茄鸡蛋&quot;); } } main方法 public class Test { public static void main(String[] args) { //模板类：父类优先定义好骨架模板final，不能被修改；具体的实现细节，推迟到给子类实现 Cook cook = new TomatoAndEgg(); cook.cookFull();//模板（执行步骤，父类一定要统一） } } 策略模式：不同用户的策略不一样，不同的环境来选择查找算法为例： 顺序查找 二分查找]]></content>
      <tags>
        <tag>Java知识点</tag>
      </tags>
  </entry>
</search>
